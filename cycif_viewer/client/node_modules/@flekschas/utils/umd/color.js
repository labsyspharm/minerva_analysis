// @flekschas/utils v0.25.0 Copyright 2020 Fritz Lekschas
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = global || self, factory(global.utils = global.utils || {}));
}(this, (function (exports) { 'use strict';

  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
  }

  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) {
      for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

      return arr2;
    }
  }

  function _iterableToArray(iter) {
    if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
  }

  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance");
  }

  /**
   * Test if a variable is an array
   * @param {*} f - The variable to test
   * @return {boolean} If `true` the variable is an array.
   */
  /**
   * Tests if a string is a valid HEX color encoding
   * @param {string} hex - HEX-encoded color string.
   * @return {boolean} If `true` the string is a valid HEX color encoding.
   */

  var isHex = function isHex(hex) {
    return /(^#[0-9A-Fa-f]{6}$)|(^#[0-9A-Fa-f]{3}$)/i.test(hex);
  };
  /**
   * Tests if a number is in `[0,1]`.
   * @param {number} x - Number to be tested.
   * @return {boolean} If `true` the number is in `[0,1]`.
   */

  var isNormFloat = function isNormFloat(x) {
    return isNumber(x) && x >= 0 && x <= 1;
  };
  /**
   * Tests if an array consist of normalized numbers that are in `[0,1]` only.
   * @param {array} a - Array to be tested
   * @return {boolean} If `true` the array contains only numbers in `[0,1]`.
   */

  var isNormFloatArray = function isNormFloatArray(a) {
    return Array.isArray(a) && a.every(isNormFloat);
  };
  /**
   * Test if a variable is a number
   * @param {*} x - Variable to be tested
   * @return {boolean} If `true`, `x` is a number.
   */

  var isNumber = function isNumber(x) {
    return typeof x === 'number';
  };
  /**
   * Tests if an array is encoding an RGB color.
   * @param {array} rgb - Array to be tested
   * @return {boolean} If `true` the array hold a triple of Uint8 numbers or
   *   a triple of normalized floats.
   */

  var isRgbArray = function isRgbArray(rgb) {
    return rgb.length === 3 && (isNormFloatArray(rgb) || isUint8Array(rgb));
  };
  /**
   * Tests if an array is encoding an RGBA color.
   * @param   {array}  rgb  Array to be tested
   * @return  {boolean}  If `true` the array hold a quadruple of normalized floats,
   *   a quadruple of Uint8s, or a triple of Uint8 and one normalized float.
   */

  var isRgbaArray = function isRgbaArray(rgba) {
    return rgba.length === 4 && (isNormFloatArray(rgba) || isUint8Array(rgba) || isUint8Array(rgba.slice(0, 3)) && isNormFloat(rgba[3]));
  };
  /**
   * Tests if a number is an interger and in `[0,255]`.
   * @param {number} x - Number to be tested.
   * @return {boolean} If `true` the number is an interger and in `[0,255]`.
   */

  var isUint8 = function isUint8(x) {
    return Number.isInteger(x) && x >= 0 && x <= 255;
  };
  /**
   * Tests if an array consist of Uint8 numbers only.
   * @param {array} a - Array to be tested.
   * @return {boolean} If `true` the array contains only Uint8 numbers.
   */

  var isUint8Array = function isUint8Array(a) {
    return Array.isArray(a) && a.every(isUint8);
  };

  /**
   * Vector L2 norm
   *
   * @description
   * This is identical but much faster than `Math.hypot(...v)`
   *
   * @param {array} v - Numerical vector
   * @return {number} L2 norm
   */

  var l2Norm = function l2Norm(v) {
    return Math.sqrt(v.reduce(function (sum, x) {
      return sum + Math.pow(x, 2);
    }, 0));
  };
  /**
   * Normalize vector
   * @param {array} v - Numerical vector
   * @return {array} Unit vector
   */

  var normalize = function normalize(v) {
    var norm = l2Norm(v);
    return v.map(function (x) {
      return x / norm;
    });
  };

  /**
   * Convert a HEX string to its decimal representation
   * @param {string} hex - HEX string
   * @return {number} Decimal representation
   */

  var decToRgb = function decToRgb(dec) {
    return [dec >> 16, (dec >> 8) % 256, dec % 256];
  };
  /**
   * Convert a HEX string to its decimal representation
   * @param {string} hex - HEX string
   * @return {number} Decimal representation
   */

  var hexToDec = function hexToDec(hex) {
    return parseInt(hex.substr(1), 16);
  };
  /**
   * Convert a HEX-encoded color to an RGB-encoded color
   * @param {string} hex - HEX-encoded color string.
   * @param {boolean} normalize - If `true` the returned RGB values will be
   *   normalized to `[0,1]`.
   * @return {array} Triple holding the RGB values.
   */

  var hexToRgbArray = function hexToRgbArray(hex) {
    var normalize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    return hex.replace(/^#?([a-f\d])([a-f\d])([a-f\d])$/i, function (m, r, g, b) {
      return "#".concat(r).concat(r).concat(g).concat(g).concat(b).concat(b);
    }).substring(1).match(/.{2}/g).map(function (x) {
      return parseInt(x, 16) / Math.pow(255, normalize);
    });
  };
  /**
   * Convert a HEX-encoded color to an RGBA-encoded color
   * @param {string} hex - HEX-encoded color string.
   * @param {boolean} normalize - If `true` the returned RGBA values will be
   *   normalized to `[0,1]`.
   * @return {array} Triple holding the RGBA values.
   */

  var hexToRgbaArray = function hexToRgbaArray(hex) {
    var normalize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    return [].concat(_toConsumableArray(hexToRgbArray(hex, normalize)), [Math.pow(255, !normalize)]);
  };
  /**
   * Convert RGB(A) string to its array representation
   * @param {string} rgbStr - RGB(A) string
   * @return {number} RGB(A) array
   */

  var rgbStrToRgbArray = function rgbStrToRgbArray(rgbStr) {
    return rgbStr.match(/[\d.]+/g).slice(0, 4).map(function (x) {
      return +x;
    });
  };
  /**
   * Same as `rgbStrToRgbArray()`
   */

  var rgbaStrToRgbaArray = rgbStrToRgbArray;
  /**
   * Convert RGB string to its decimal representation
   * @param {string} rgbStr - RGB string
   * @return {number} Decimal representation
   */

  var rgbStrToDec = function rgbStrToDec(rgbStr) {
    return rgbStrToRgbArray(rgbStr).slice(0, 3) // eslint-disable-next-line no-bitwise
    .map(function (x, i) {
      return +x << 8 * (2 - i);
    }).reduce(function (x, sum) {
      return sum + x;
    }, 0);
  };
  /**
   * Convert RGB values to a HEX string
   * @param {number} r - Red component
   * @param {number} g - Green component
   * @param {number} b - Blue component
   * @return {string} HEX string
   */

  var rgbToHex = function rgbToHex(r, g, b) {
    var componentToHex = function componentToHex(c) {
      var hex = c.toString(16);
      return hex.length === 1 ? "0".concat(hex) : hex;
    };

    return "#".concat(componentToHex(r)).concat(componentToHex(g)).concat(componentToHex(b));
  };
  /**
   * Convert a color to an RGBA color
   * @param {*} color - Color to be converted. Currently supports:
   *   HEX, RGB, or RGBA.
   * @param {boolean} normalize - If `true` the returned RGBA values will be
   *   normalized to `[0,1]`.
   * @return{array} Quadruple defining an RGBA color.
   */

  var toRgbaArray = function toRgbaArray(color, normalize$1) {
    if (isRgbaArray(color)) return normalize$1 && !isNormFloatArray(color) ? normalize$1(color) : color;
    if (isRgbArray(color)) return [].concat(_toConsumableArray(normalize$1 ? normalize(color) : color), [Math.pow(255, !normalize$1)]);
    if (isHex(color)) return hexToRgbaArray(color, normalize$1);
    console.warn('Only HEX, RGB, and RGBA are handled by this function. Returning white instead.');
    return normalize$1 ? [1, 1, 1, 1] : [255, 255, 255, 255];
  };

  exports.decToRgb = decToRgb;
  exports.hexToDec = hexToDec;
  exports.hexToRgbArray = hexToRgbArray;
  exports.hexToRgbaArray = hexToRgbaArray;
  exports.rgbStrToDec = rgbStrToDec;
  exports.rgbStrToRgbArray = rgbStrToRgbArray;
  exports.rgbToHex = rgbToHex;
  exports.rgbaStrToRgbaArray = rgbaStrToRgbaArray;
  exports.toRgbaArray = toRgbaArray;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
