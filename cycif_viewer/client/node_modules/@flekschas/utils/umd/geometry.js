// @flekschas/utils v0.25.0 Copyright 2020 Fritz Lekschas
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = global || self, factory(global.utils = global.utils || {}));
}(this, (function (exports) { 'use strict';

  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
  }

  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }

  function _iterableToArrayLimit(arr, i) {
    if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) {
      return;
    }

    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance");
  }

  /**
   * L distance between a pair of vectors
   *
   * @description
   * Identical but much faster than `lDist(l)([fromX, fromY], [toX, toY])`
   *
   * @param {number} l - Defines the Lp space
   */
  var lPointDist = function lPointDist(l) {
    return (
      /**
       * L distance function
       * @param {number} fromX - X coordinate of the first point
       * @param {number} fromY - Y coordinate of the first point
       * @param {number} toX - X coordinate of the second point
       * @param {number} toY - Y coordinate of the first point
       * @return {array} L distance
       */
      function (fromX, fromY, toX, toY) {
        return Math.pow(Math.pow(Math.abs(fromX - toX), l) + Math.pow(Math.abs(fromY - toY), l), 1 / l);
      }
    );
  };
  /**
   * L1 distance between a pair of points
   *
   * @description
   * Identical but much faster than `l1Dist([fromX, fromY], [toX, toY])`
   *
   * @param {number} fromX - X coordinate of the first point
   * @param {number} fromY - Y coordinate of the first point
   * @param {number} toX - X coordinate of the second point
   * @param {number} toY - Y coordinate of the first point
   * @return {number} L1 distance
   */

  var l1PointDist = function l1PointDist(fromX, fromY, toX, toY) {
    return Math.abs(fromX - toX) + Math.abs(fromY - toY);
  };
  /**
   * L2 distance between a pair of points
   *
   * @description
   * Identical but much faster than `l2Dist([fromX, fromY], [toX, toY])`
   *
   * @param {number} fromX - X coordinate of the first point
   * @param {number} fromY - Y coordinate of the first point
   * @param {number} toX - X coordinate of the second point
   * @param {number} toY - Y coordinate of the first point
   * @return {number} L2 distance
   */

  var l2PointDist = function l2PointDist(fromX, fromY, toX, toY) {
    return Math.sqrt(Math.pow(fromX - toX, 2) + Math.pow(fromY - toY, 2));
  };
  /**
   * L distance between a pair of rectangles
   *
   * @param {number} l - Defines the Lp space
   */

  var lRectDist = function lRectDist(l) {
    return (
      /**
       * L distance function between a pair of rectangles
       *
       * @param {object} bBox1 - Bounding box of the first rectangle
       * @param {object} bBox2 - Bounding box of the second rectangle
       * @return {number} L distance of the closest boundary points
       */
      function (bBox1, bBox2) {
        var xd1 = bBox2.minX - bBox1.minX;
        var xd2 = bBox2.minX - bBox1.maxX;
        var xd3 = bBox2.maxX - bBox1.minX;
        var xd4 = bBox2.maxX - bBox1.maxX;
        var isXInside = // bBox1 is x-wise inside of bBox2
        xd1 < 0 && xd3 > 0 || xd2 < 0 && xd4 > 0 || // bBox2 is x-wise inside of bBox1
        xd1 > 0 && xd2 < 0 || xd3 > 0 && xd4 < 0;
        var yd1 = bBox2.minY - bBox1.minY;
        var yd2 = bBox2.minY - bBox1.maxY;
        var yd3 = bBox2.maxY - bBox1.minY;
        var yd4 = bBox2.maxY - bBox1.maxY;
        var isYInside = // bBox1 is y-wise inside of bBox2
        yd1 < 0 && yd3 > 0 || yd2 < 0 && yd4 > 0 || // bBox2 is y-wise inside of bBox1
        yd1 > 0 && yd2 < 0 || yd3 > 0 && yd4 < 0;
        if (isXInside && isYInside) return 0;
        var minYDist = Math.min(Math.abs(yd1), Math.abs(yd2), Math.abs(yd3), Math.abs(yd4));
        if (isXInside) return minYDist;
        var minXDist = Math.min(Math.abs(xd1), Math.abs(xd2), Math.abs(xd3), Math.abs(xd4));
        if (isYInside) return minXDist;
        return Math.pow(Math.pow(minXDist, l) + Math.pow(minYDist, l), 1 / l);
      }
    );
  };
  /**
   * From: https://wrf.ecse.rpi.edu//Research/Short_Notes/pnpoly.html
   * @param   {Array}  point  Tuple of the form `[x,y]` to be tested.
   * @param   {Array}  polygon  1D list of vertices defining the polygon.
   * @return  {boolean}  If `true` point lies within the polygon.
   */

  var isPointInPolygon = function isPointInPolygon() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [],
        _ref2 = _slicedToArray(_ref, 2),
        px = _ref2[0],
        py = _ref2[1];

    var polygon = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    var x1;
    var y1;
    var x2;
    var y2;
    var isWithin = false;

    for (var i = 0, j = polygon.length - 2; i < polygon.length; i += 2) {
      x1 = polygon[i];
      y1 = polygon[i + 1];
      x2 = polygon[j];
      y2 = polygon[j + 1];
      if (y1 > py !== y2 > py && px < (x2 - x1) * (py - y1) / (y2 - y1) + x1) isWithin = !isWithin;
      j = i;
    }

    return isWithin;
  };
  /**
   * Check if a 2D or 1D point is within a rectangle or range
   * @param   {number}  x  The point's X coordinate.
   * @param   {number}  y  The point's Y coordinate.
   * @param   {number}  minX  The rectangle's start X coordinate.
   * @param   {number}  maxX  The rectangle's start X coordinate.
   * @param   {number}  minY  The rectangle's start X coordinate.
   * @param   {number}  maxY  The rectangle's start X coordinate.
   * @return  {boolean}  If `true` the [x,y] point is in the rectangle.
   */

  var isPointInRect = function isPointInRect(_ref3, _ref4) {
    var _ref5 = _slicedToArray(_ref3, 2),
        x = _ref5[0],
        y = _ref5[1];

    var _ref6 = _slicedToArray(_ref4, 4),
        minX = _ref6[0],
        maxX = _ref6[1],
        minY = _ref6[2],
        maxY = _ref6[3];

    return x >= minX && x <= maxX && y >= minY && y <= maxY;
  };
  /**
   * Check if a 2D or 1D point is within a rectangle or range
   * @param   {number}  x  The point's X coordinate.
   * @param   {number}  y  The point's Y coordinate.
   * @param   {number}  minX  The rectangle's start X coordinate.
   * @param   {number}  maxX  The rectangle's start X coordinate.
   * @param   {number}  minY  The rectangle's start X coordinate.
   * @param   {number}  maxY  The rectangle's start X coordinate.
   * @return  {boolean}  If `true` the [x,y] point is in the rectangle.
   */

  var isPointHalfwayInRect = function isPointHalfwayInRect(_ref7, _ref8) {
    var _ref9 = _slicedToArray(_ref7, 2),
        x = _ref9[0],
        y = _ref9[1];

    var _ref10 = _slicedToArray(_ref8, 4),
        minX = _ref10[0],
        maxX = _ref10[1],
        minY = _ref10[2],
        maxY = _ref10[3];

    return x >= minX && x <= maxX || y >= minY && y <= maxY;
  };

  exports.isPointHalfwayInRect = isPointHalfwayInRect;
  exports.isPointInPolygon = isPointInPolygon;
  exports.isPointInRect = isPointInRect;
  exports.l1PointDist = l1PointDist;
  exports.l2PointDist = l2PointDist;
  exports.lPointDist = lPointDist;
  exports.lRectDist = lRectDist;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
