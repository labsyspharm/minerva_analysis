// @flekschas/utils v0.25.0 Copyright 2020 Fritz Lekschas
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = global || self, factory(global.utils = global.utils || {}));
}(this, (function (exports) { 'use strict';

  /**
   * Debounce a function call.
   *
   * @description
   * Function calls are delayed by `wait` milliseconds and only one out of
   * multiple function calls is executed.
   *
   * @param {function} fn - Function to be debounced
   * @param {number} wait - Number of milliseconds to debounce the function call.
   * @return {function} Debounced function
   */
  var debounce = function debounce(fn, wait) {
    var timeout;

    var debounced = function debounced() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      var later = function later() {
        timeout = null;
        fn.apply(void 0, args);
      };

      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
    };

    debounced.cancel = function () {
      clearTimeout(timeout);
    };

    debounced.now = function () {
      return fn.apply(void 0, arguments);
    };

    return debounced;
  };
  /**
   * Get a promise that resolves after the next `n` animation frames
   * @param {number} n - Number of animation frames to wait
   * @return {Promise} A promise that resolves after the next `n` animation frames
   */

  var nextAnimationFrame = function nextAnimationFrame() {
    var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
    return new Promise(function (resolve) {
      var i = 0;

      var raf = function raf() {
        return requestAnimationFrame(function () {
          i++;
          if (i < n) raf();else resolve();
        });
      };

      raf();
    });
  };
  /**
   * Throttle a function
   *
   * @description
   * A throttled function will only ever be called every `wait` milliseconds at
   * most.
   *
   * @param {function} fn - Function to be throttled
   * @param {number} wait - Number of milliseconds calls are throttled
   * @return {function} Throttled function
   */

  var throttle = function throttle(fn, wait) {
    var isWaiting = false;

    var throttled = function throttled() {
      if (!isWaiting) {
        fn.apply(void 0, arguments);
        isWaiting = true;
        setTimeout(function () {
          isWaiting = false;
        }, wait);
      }
    };

    throttled.reset = function () {
      isWaiting = false;
    };

    throttled.now = function () {
      return fn.apply(void 0, arguments);
    };

    return throttled;
  };
  /**
   * Throttle and debounce a function call
   *
   * Throttling a function call means that the function is called at most every
   * `interval` milliseconds no matter how frequently you trigger a call.
   * Debouncing a function call means that the function is called the earliest
   * after `finalWait` milliseconds wait time where the function was not called.
   * Combining the two ensures that the function is called at most every
   * `interval` milliseconds and is ensured to be called with the very latest
   * arguments after after `finalWait` milliseconds wait time at the end.
   *
   * The following imaginary scenario describes the behavior:
   *
   * MS | throttleTime=3 and debounceTime=3
   * 1. y(f, 3, 3)(args1) => f(args1) called
   * 2. y(f, 3, 3)(args2) => call ignored due to throttling
   * 3. y(f, 3, 3)(args3) => call ignored due to throttling
   * 4. y(f, 3, 3)(args4) => f(args4) called
   * 5. y(f, 3, 3)(args5) => all ignored due to throttling
   * 6. No call           => nothing
   * 7. No call           => f(args5) called due to debouncing
   *
   * @param {functon} func - Function to be throttled and debounced
   * @param {number} interval - Throttle intevals in milliseconds
   * @param {number} wait - Debounce wait time in milliseconds By default this is
   *   the same as `interval`.
   * @return {function} - Throttled and debounced function
   */

  var throttleAndDebounce = function throttleAndDebounce(fn, throttleTime) {
    var debounceTime = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    var timeout;
    var blockedCalls = 0; // eslint-disable-next-line no-param-reassign

    debounceTime = debounceTime === null ? throttleTime : debounceTime;

    var debounced = function debounced() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      var later = function later() {
        // Since we throttle and debounce we should check whether there were
        // actually multiple attempts to call this function after the most recent
        // throttled call. If there were no more calls we don't have to call
        // the function again.
        if (blockedCalls > 0) {
          fn.apply(void 0, args);
          blockedCalls = 0;
        }
      };

      clearTimeout(timeout);
      timeout = setTimeout(later, debounceTime);
    };

    var isWaiting = false;

    var throttledAndDebounced = function throttledAndDebounced() {
      if (!isWaiting) {
        fn.apply(void 0, arguments);
        debounced.apply(void 0, arguments);
        isWaiting = true;
        blockedCalls = 0;
        setTimeout(function () {
          isWaiting = false;
        }, throttleTime);
      } else {
        blockedCalls++;
        debounced.apply(void 0, arguments);
      }
    };

    throttledAndDebounced.reset = function () {
      isWaiting = false;
    };

    throttledAndDebounced.cancel = function () {
      clearTimeout(timeout);
    };

    throttledAndDebounced.now = function () {
      return fn.apply(void 0, arguments);
    };

    return throttledAndDebounced;
  };
  /**
   * Promise that resolves after some time
   * @param {number} msec - Time in milliseconds until the promise is resolved
   * @return {Promise} Promise resolving after `msec` milliseconds
   */

  var wait = function wait(msec) {
    return new Promise(function (resolve) {
      return setTimeout(resolve, msec);
    });
  };

  exports.debounce = debounce;
  exports.nextAnimationFrame = nextAnimationFrame;
  exports.throttle = throttle;
  exports.throttleAndDebounce = throttleAndDebounce;
  exports.wait = wait;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
