// @flekschas/utils v0.25.0 Copyright 2020 Fritz Lekschas
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = global || self, factory(global.utils = global.utils || {}));
}(this, (function (exports) { 'use strict';

  /**
   * Identity function
   * @param   {*}  x  Any kind of value
   * @return  {*}  `x`
   */
  var identity = function identity(x) {
    return x;
  };

  /**
   * Test if a variable is an array
   * @param {*} f - The variable to test
   * @return {boolean} If `true` the variable is an array.
   */
  /**
   * Test if a variable is a function
   * @param {*} f - The variable to test
   * @return {boolean} If `true` the variable is a function.
   */

  var isFunction = function isFunction(f) {
    return !!(f && f.constructor && f.call && f.apply);
  };

  /**
   * Aggregate a vector using one or more aggregators. Like a multi-purpose reducer.
   * @param {array} v - Numerivcal vector
   * @param {array|function} aggregater - A single or multiple aggregator functions. The aggregator functions work like reducers.
   * @param {array|number} startValue - A single or multiple start values
   * @param {function} options.getter - A value getter
   * @return {array|number} A single or multiple aggregagted values
   */

  var aggregate = function aggregate(v, aggregater, startValue) {
    var _ref = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {},
        _ref$getter = _ref.getter,
        getter = _ref$getter === void 0 ? identity : _ref$getter;

    var isSingle = isFunction(aggregater);
    var aggregaters = isSingle ? [aggregater] : aggregater;
    var startValues = isSingle ? [startValue] : startValue;
    var out = v.reduce(function (aggregates, x) {
      return aggregaters.map(function (fn, i) {
        return fn(aggregates[i], getter(x));
      });
    }, startValues === undefined ? Array(aggregaters.length).fill(0) : startValues);
    return isSingle ? out[0] : out;
  };
  /**
   * Get the difference of two vectoe
   * @param {array} v - Numerical vectors
   * @param {array} w - Numerical vectors
   * @return {array} Difference vector
   */

  var diff = function diff(v, w) {
    return v.map(function (x, i) {
      return x - w[i];
    });
  };
  /**
   * L distance between a pair of vectors
   *
   * @param {array} l - Defines the Lp space
   * @param {number} dim - Dimension of the input data (Optional)
   */

  var lDist = function lDist(l, dim) {
    if (Number.isNaN(+dim)) {
      /**
       * L distance function
       * @param {array} v - First vector
       * @param {array} w - Second vector
       * @return {array} L distance
       */
      return function (v, w) {
        return v.length === w.length ? Math.pow(v.reduce(function (sum, x, i) {
          return sum + Math.pow(Math.abs(x - w[i]), l);
        }, 0), 1 / l) : undefined;
      };
    }

    var body = Array(dim).fill().map(function (_, i) {
      return "s += Math.abs(v[".concat(i, "] - w[").concat(i, "]) ** l;");
    }).join(' '); // eslint-disable-next-line no-new-func

    return new Function('v', 'w', "const l = ".concat(l, "; let s = 0; ").concat(body, " return s ** (1 / l);"));
  };
  /**
   * L1 distance between a pair of vectors
   *
   * @description
   * This is identical but much faster than `lDist(1)(v, w)`
   *
   * @param {array} v - First vector
   * @param {array} w - Second vector
   * @return {array} L2 distance
   */

  var l1Dist = function l1Dist(v, w) {
    return v.length === w.length ? v.reduce(function (sum, x, i) {
      return sum + Math.abs(x - w[i]);
    }, 0) : undefined;
  };
  /**
   * Creates a l1 distance function tailored to the dimension of the data
   *
   * @description
   * This is identical but faster than `l1Dist(v, w)`
   *
   * @param {number} dim - Dimension of the input data
   * @return {function} A function with the same signature as `l1Dist`
   */

  var l1DistByDim = function l1DistByDim(dim) {
    var body = Array(dim).fill().map(function (_, i) {
      return "s += Math.abs(v[".concat(i, "] - w[").concat(i, "]);");
    }).join(' '); // eslint-disable-next-line no-new-func

    return new Function('v', 'w', "let s = 0; ".concat(body, " return s;"));
  };
  /**
   * L2 distance between a pair of vectors
   *
   * @description
   * This is identical but much faster than `lDist(2)(v, w)`
   *
   * @param {array} v - First vector
   * @param {array} w - Second vector
   * @return {array} L2 distance
   */

  var l2Dist = function l2Dist(v, w) {
    return v.length === w.length ? Math.sqrt(v.reduce(function (sum, x, i) {
      return sum + Math.pow(x - w[i], 2);
    }, 0)) : undefined;
  };
  /**
   * Creates a l2 distance function tailored to the dimension of the data
   *
   * @description
   * This is identical but faster than `l2Dist(v, w)`
   *
   * @param {number} dim - Dimension of the input data
   * @return {function} A function with the same signature as `l2Dist`
   */

  var l2DistByDim = function l2DistByDim(dim) {
    var body = Array(dim).fill().map(function (_, i) {
      return "s += Math.pow(v[".concat(i, "] - w[").concat(i, "], 2);");
    }).join(' '); // eslint-disable-next-line no-new-func

    return new Function('v', 'w', "let s = 0; ".concat(body, " return Math.sqrt(s);"));
  };
  /**
   * Vector L2 norm
   *
   * @description
   * This is identical but much faster than `Math.hypot(...v)`
   *
   * @param {array} v - Numerical vector
   * @return {number} L2 norm
   */

  var l2Norm = function l2Norm(v) {
    return Math.sqrt(v.reduce(function (sum, x) {
      return sum + Math.pow(x, 2);
    }, 0));
  };
  /**
   * Get the maximum number of a vector while ignoring NaNs
   *
   * @description
   * This version is muuuch faster than `Math.max(...v)`.
   *
   * @param {array} v - Numerical vector
   * @return {number} The largest number
   */

  var max = function max(v) {
    return v.reduce(function (_max, a) {
      return a > _max ? a : _max;
    }, -Infinity);
  };
  var maxNan = max;
  /**
   * Get the max vector
   * @param {array} m - Array of vectors
   * @return {array} Max vector
   */

  var maxVector = function maxVector(m) {
    switch (m.length) {
      case 0:
        return [];

      case 1:
        return m[0];

      default:
        return m.reduce(function (_max, v) {
          return v.map(function (x, i) {
            return _max[i] > x ? _max[i] : x;
          });
        }, new Array(m[0].length).fill(-Infinity));
    }
  };
  /**
   * Get the mean of a vector
   *
   * @param {array} v - Numerical vector
   * @return {number} The mean
   */

  var mean = function mean(v) {
    return sum(v) / v.length;
  };
  /**
   * Get the mean of a vector while ignoring NaNs
   *
   * @description
   * Roughly 30% slower than `mean()`
   *
   * @param {array} v - Numerical vector
   * @return {number} The mean
   */

  var meanNan = function meanNan(v) {
    var length = 0;
    return v.reduce(function (s, x) {
      if (x || x === 0) return ++length && s + x;
      return s;
    }, 0) / length;
  };
  /**
   * Get the mean vector
   * @param {array} m - Array of vectors
   * @return {array} Mean vector
   */

  var meanVector = function meanVector(m) {
    switch (m.length) {
      case 0:
        return [];

      case 1:
        return m[0];

      default:
        return m.reduce(function (_mean, v) {
          return v.map(function (x, i) {
            return _mean[i] + x / m.length;
          });
        }, new Array(m[0].length).fill(0));
    }
  };
  /**
   * Get the median of a vector
   *
   * @param {array} v - Numerical vector
   * @return {number} The median
   */

  var median = function median(v) {
    return v[Math.floor(v.length / 2)];
  };
  /**
   * Get the median vector
   * @param {array} m - Array of vectors
   * @return {array} The median vector
   */

  var medianVector = median;
  /**
   * Get the minimum number of a vector while ignoring NaNs
   *
   * @description
   * This version is muuuch faster than `Math.min(...v)` and support longer
   * vectors than 256^2, which is a limitation of `Math.min.apply(null, v)`.
   *
   * @param {array} v - Numerical vector
   * @return {number} The smallest number
   */

  var min = function min(v) {
    return v.reduce(function (_min, a) {
      return a < _min ? a : _min;
    }, Infinity);
  };
  var minNan = min;
  /**
   * Get the min vector
   * @param {array} m - Array of vectors
   * @return {array} Min vector
   */

  var minVector = function minVector(m) {
    switch (m.length) {
      case 0:
        return [];

      case 1:
        return m[0];

      default:
        return m.reduce(function (_min, v) {
          return v.map(function (x, i) {
            return _min[i] < x ? _min[i] : x;
          });
        }, new Array(m[0].length).fill(Infinity));
    }
  };
  /**
   * Non-negative modulo function. E.g., `mod(-1, 5) === 4` while `-1 % 5 === -1`.
   *
   * @param {number} x - Dividend
   * @param {number} y - Divisor
   * @return {number} Remainder
   */

  var mod = function mod(x, y) {
    return (x % y + x) % y;
  };
  /**
   * Normalize vector
   * @param {array} v - Numerical vector
   * @return {array} Unit vector
   */

  var normalize = function normalize(v) {
    var norm = l2Norm(v);
    return v.map(function (x) {
      return x / norm;
    });
  };
  /**
   * A function to created a range array
   * @param   {number}  start  Start of the range (included)
   * @param   {number}  end  End of the range (excluded)
   * @param   {number}  stepSize  Increase per step
   * @return  {array}  Range array
   */

  var range = function range(start, end) {
    var stepSize = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
    return Array(Math.ceil((end - start) / stepSize)).fill().map(function (x, i) {
      return start + i * stepSize;
    });
  };
  /**
   * Get the sum of a vector while ignoring NaNs
   *
   * @description
   *
   *
   * @param {array} v - Numerical vector
   * @return {number} The sum
   */

  var sum = function sum(values) {
    return values.reduce(function (s, v) {
      // Any falsey value (e.g., 0, null, NaN) does not influence the sum
      if (v) return s + v;
      return s;
    }, 0);
  };
  var sumNan = sum;
  /**
   * Get the sum vector
   * @param {array} m - Array of vectors
   * @return {array} Sum vector
   */

  var sumVector = function sumVector(m) {
    switch (m.length) {
      case 0:
        return [];

      case 1:
        return m[0];

      default:
        return m.reduce(function (_sum, v) {
          return v.map(function (x, i) {
            return _sum[i] + x;
          });
        }, new Array(m[0].length).fill(0));
    }
  };

  exports.aggregate = aggregate;
  exports.diff = diff;
  exports.l1Dist = l1Dist;
  exports.l1DistByDim = l1DistByDim;
  exports.l2Dist = l2Dist;
  exports.l2DistByDim = l2DistByDim;
  exports.l2Norm = l2Norm;
  exports.lDist = lDist;
  exports.max = max;
  exports.maxNan = maxNan;
  exports.maxVector = maxVector;
  exports.mean = mean;
  exports.meanNan = meanNan;
  exports.meanVector = meanVector;
  exports.median = median;
  exports.medianVector = medianVector;
  exports.min = min;
  exports.minNan = minNan;
  exports.minVector = minVector;
  exports.mod = mod;
  exports.normalize = normalize;
  exports.range = range;
  exports.sum = sum;
  exports.sumNan = sumNan;
  exports.sumVector = sumVector;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
