// @flekschas/utils v0.25.0 Copyright 2020 Fritz Lekschas
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = global || self, factory(global.utils = {}));
}(this, (function (exports) { 'use strict';

  /* eslint no-param-reassign:0 */

  /**
   * Cubic in easing function
   * @param {number} t - The input time to be eased. Must be in [0, 1] where `0`
   *   refers to the start and `1` to the end
   * @return {number} The eased time
   */
  var cubicIn = function cubicIn(t) {
    return t * t * t;
  };
  /**
   * Cubic in and out easing function
   * @param {number} t - The input time to be eased. Must be in [0, 1] where `0`
   *   refers to the start and `1` to the end
   * @return {number} The eased time
   */

  var cubicInOut = function cubicInOut(t) {
    return t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;
  };
  /**
   * Cubic out easing function
   * @param {number} t - The input time to be eased. Must be in [0, 1] where `0`
   *   refers to the start and `1` to the end
   * @return {number} The eased time
   */

  var cubicOut = function cubicOut(t) {
    return --t * t * t + 1;
  };
  /**
   * Linearly interpolate two numbers
   * @param {number} a - The start value
   * @param {number} b - The end value
   * @param {number} p - The interpolation progress. Must be in [0, 1] where `0`
   *   refers to the start value and `1` to the end value
   * @return {number} The interpolated number
   */

  var interpolateNumber = function interpolateNumber(a, b, p) {
    // eslint-disable-next-line no-param-reassign
    p = Math.min(1, Math.max(0, p));
    return a * (1 - p) + b * p;
  };
  /**
   * Lineraly interpolate a numerical vector
   * @param {array} a - The start vector
   * @param {array} b - The end vector
   * @param {number} p - The interpolation progress. Must be in [0, 1] where `0`
   *   refers to the start vector and `1` to the end vector
   * @return {array} The interpolated vector
   */

  var interpolateVector = function interpolateVector(a, b, p) {
    return a.map(function (x, i) {
      return interpolateNumber(x, b[i], p);
    });
  };
  /**
   * Linear easing function
   * @param {number} t - The input time to be eased. Must be in [0, 1] where `0`
   *   refers to the start and `1` to the end
   * @return {number} Same as the input
   */

  var linear = function linear(t) {
    return t;
  };
  /**
   * Quadratic in easing function
   * @param {number} t - The input time to be eased. Must be in [0, 1] where `0`
   *   refers to the start and `1` to the end
   * @return {number} The eased time
   */

  var quadIn = function quadIn(t) {
    return t * t;
  };
  /**
   * Quadratic in and out easing function
   * @param {number} t - The input time to be eased. Must be in [0, 1] where `0`
   *   refers to the start and `1` to the end
   * @return {number} The eased time
   */

  var quadInOut = function quadInOut(t) {
    return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
  };
  /**
   * Quadratic out easing function
   * @param {number} t - The input time to be eased. Must be in [0, 1] where `0`
   *   refers to the start and `1` to the end
   * @return {number} The eased time
   */

  var quadOut = function quadOut(t) {
    return t * (2 - t);
  };
  /**
   * Quartic in easing function
   * @param {number} t - The input time to be eased. Must be in [0, 1] where `0`
   *   refers to the start and `1` to the end
   * @return {number} The eased time
   */

  var quartIn = function quartIn(t) {
    return t * t * t * t;
  };
  /**
   * Quartic in and out easing function
   * @param {number} t - The input time to be eased. Must be in [0, 1] where `0`
   *   refers to the start and `1` to the end
   * @return {number} The eased time
   */

  var quartOut = function quartOut(t) {
    return 1 - --t * t * t * t;
  };
  /**
   * Quartic out easing function
   * @param {number} t - The input time to be eased. Must be in [0, 1] where `0`
   *   refers to the start and `1` to the end
   * @return {number} The eased time
   */

  var quartInOut = function quartInOut(t) {
    return t < 0.5 ? 8 * t * t * t * t : 1 - 8 * --t * t * t * t;
  };
  /**
   * Quintic in easing function
   * @param {number} t - The input time to be eased. Must be in [0, 1] where `0`
   *   refers to the start and `1` to the end
   * @return {number} The eased time
   */

  var quintIn = function quintIn(t) {
    return t * t * t * t * t;
  };
  /**
   * Quintic in and out easing function
   * @param {number} t - The input time to be eased. Must be in [0, 1] where `0`
   *   refers to the start and `1` to the end
   * @return {number} The eased time
   */

  var quintOut = function quintOut(t) {
    return 1 + --t * t * t * t * t;
  };
  /**
   * Quintic out easing function
   * @param {number} t - The input time to be eased. Must be in [0, 1] where `0`
   *   refers to the start and `1` to the end
   * @return {number} The eased time
   */

  var quintInOut = function quintInOut(t) {
    return t < 0.5 ? 16 * t * t * t * t * t : 1 + 16 * --t * t * t * t * t;
  };

  function _typeof(obj) {
    "@babel/helpers - typeof";

    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function (obj) {
        return typeof obj;
      };
    } else {
      _typeof = function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof(obj);
  }

  function _defineEnumerableProperties(obj, descs) {
    for (var key in descs) {
      var desc = descs[key];
      desc.configurable = desc.enumerable = true;
      if ("value" in desc) desc.writable = true;
      Object.defineProperty(obj, key, desc);
    }

    if (Object.getOwnPropertySymbols) {
      var objectSymbols = Object.getOwnPropertySymbols(descs);

      for (var i = 0; i < objectSymbols.length; i++) {
        var sym = objectSymbols[i];
        var desc = descs[sym];
        desc.configurable = desc.enumerable = true;
        if ("value" in desc) desc.writable = true;
        Object.defineProperty(obj, sym, desc);
      }
    }

    return obj;
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
  }

  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
  }

  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) {
      for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

      return arr2;
    }
  }

  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }

  function _iterableToArray(iter) {
    if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
  }

  function _iterableToArrayLimit(arr, i) {
    if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) {
      return;
    }

    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance");
  }

  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance");
  }

  /**
   * Identity function
   * @param   {*}  x  Any kind of value
   * @return  {*}  `x`
   */
  var identity = function identity(x) {
    return x;
  };
  /**
   * Test if two floats are close given some precision
   * @param {number} a - First float
   * @param {number} b - Second float
   * @param {number} precision - Number of decimal places to check
   * @return {boolean} If `true` the difference between the floats is less than
   *   10^-precision
   */

  var isClose = function isClose(a, b) {
    var precision = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 6;
    return Math.abs(a - b) < Math.pow(10, -precision);
  };

  /**
   * Transpose a nested 2D array
   * @param {array} matrix - The matrix-liked 2D nested array to be transposed
   * @return {array} The transposed 2D nested matrix-like array
   */

  var array2dTranspose = function array2dTranspose(matrix) {
    // Create a nested 2D array with transposed shape
    var out = _toConsumableArray(new Array(matrix[0].length).fill().map(function () {
      return [];
    })); // Fill the transposed array


    for (var i = 0; i < matrix.length; i++) {
      for (var j = 0; j < matrix[i].length; j++) {
        out[j][i] = matrix[i][j];
      }
    }

    return out;
  };
  /**
   * Clear an array without while keeping it's reference
   * @param {array} a - Array to be cleared
   * @return {array} The array itself
   */

  var clearArray = function clearArray(a) {
    a.splice(0, a.length);
    return a;
  };
  /**
   * Return unique values of an array
   * @param {array} a - Input array
   * @return {array} Array with unique values
   */

  var unique = function unique(a) {
    var getter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : identity;
    var s = new Set();
    var out = [];

    for (var i = 0; i < a.length; i++) {
      var v = getter(a[i]);

      if (!s.has(v)) {
        s.add(v);
        out.push(v);
      }
    }

    return out;
  };

  /**
   * Test if a variable is an array
   * @param {*} f - The variable to test
   * @return {boolean} If `true` the variable is an array.
   */
  var isArray = Array.isArray;
  /**
   * Test if a variable is a function
   * @param {*} f - The variable to test
   * @return {boolean} If `true` the variable is a function.
   */

  var isFunction = function isFunction(f) {
    return !!(f && f.constructor && f.call && f.apply);
  };
  /**
   * Tests if a string is a valid HEX color encoding
   * @param {string} hex - HEX-encoded color string.
   * @return {boolean} If `true` the string is a valid HEX color encoding.
   */

  var isHex = function isHex(hex) {
    return /(^#[0-9A-Fa-f]{6}$)|(^#[0-9A-Fa-f]{3}$)/i.test(hex);
  };
  /**
   * Tests if a number is in `[0,1]`.
   * @param {number} x - Number to be tested.
   * @return {boolean} If `true` the number is in `[0,1]`.
   */

  var isNormFloat = function isNormFloat(x) {
    return isNumber(x) && x >= 0 && x <= 1;
  };
  /**
   * Tests if an array consist of normalized numbers that are in `[0,1]` only.
   * @param {array} a - Array to be tested
   * @return {boolean} If `true` the array contains only numbers in `[0,1]`.
   */

  var isNormFloatArray = function isNormFloatArray(a) {
    return Array.isArray(a) && a.every(isNormFloat);
  };
  /**
   * Test if a variable is a number
   * @param {*} x - Variable to be tested
   * @return {boolean} If `true`, `x` is a number.
   */

  var isNumber = function isNumber(x) {
    return typeof x === 'number';
  };
  /**
   * Test if a variable is a plain object, e.g., `{}`
   * @param {*} o - The variable to test
   * @return {boolean} If `true` the variable is a plain object.
   */

  var isObject = function isObject(o) {
    return !!o && o.constructor === Object;
  };
  /**
   * Tests if an array is encoding an RGB color.
   * @param {array} rgb - Array to be tested
   * @return {boolean} If `true` the array hold a triple of Uint8 numbers or
   *   a triple of normalized floats.
   */

  var isRgbArray = function isRgbArray(rgb) {
    return rgb.length === 3 && (isNormFloatArray(rgb) || isUint8Array(rgb));
  };
  /**
   * Tests if an array is encoding an RGBA color.
   * @param   {array}  rgb  Array to be tested
   * @return  {boolean}  If `true` the array hold a quadruple of normalized floats,
   *   a quadruple of Uint8s, or a triple of Uint8 and one normalized float.
   */

  var isRgbaArray = function isRgbaArray(rgba) {
    return rgba.length === 4 && (isNormFloatArray(rgba) || isUint8Array(rgba) || isUint8Array(rgba.slice(0, 3)) && isNormFloat(rgba[3]));
  };
  /**
   * Tests if a string is encoding an RGB color.
   * @param {string} rgb - String to be tested
   * @return {boolean} If `true` the array hold a triple of Uint8 numbers or
   *   a triple of normalized floats.
   */

  var isRgbStr = function isRgbStr(str) {
    return /rgb\(\s*[\d.]+\s*,\s*[\d.]+\s*,\s*[\d.]+\s*\)/i.test(str);
  };
  /**
   * Tests if a string is encoding an RGBA color.
   * @param {string} rgb - String to be tested
   * @return {boolean} If `true` the array hold a quadruple of Uint8 numbers or
   *   a quadruple of normalized floats.
   */

  var isRgbaStr = function isRgbaStr(str) {
    return /rgba\(\s*[\d.]+\s*,\s*[\d.]+\s*,\s*[\d.]+\s*,\s*[\d.]+\s*\)/i.test(str);
  };
  /**
   * Tests if a variable is a string
   * @param {*} s - Variable to be tested
   * @return {boolean} If `true` variable is a string
   */

  var isString = function isString(s) {
    return typeof s === 'string' || s instanceof String;
  };
  /**
   * Tests if a number is an interger and in `[0,255]`.
   * @param {number} x - Number to be tested.
   * @return {boolean} If `true` the number is an interger and in `[0,255]`.
   */

  var isUint8 = function isUint8(x) {
    return Number.isInteger(x) && x >= 0 && x <= 255;
  };
  /**
   * Tests if an array consist of Uint8 numbers only.
   * @param {array} a - Array to be tested.
   * @return {boolean} If `true` the array contains only Uint8 numbers.
   */

  var isUint8Array = function isUint8Array(a) {
    return Array.isArray(a) && a.every(isUint8);
  };

  /**
   * Aggregate a vector using one or more aggregators. Like a multi-purpose reducer.
   * @param {array} v - Numerivcal vector
   * @param {array|function} aggregater - A single or multiple aggregator functions. The aggregator functions work like reducers.
   * @param {array|number} startValue - A single or multiple start values
   * @param {function} options.getter - A value getter
   * @return {array|number} A single or multiple aggregagted values
   */

  var aggregate = function aggregate(v, aggregater, startValue) {
    var _ref = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {},
        _ref$getter = _ref.getter,
        getter = _ref$getter === void 0 ? identity : _ref$getter;

    var isSingle = isFunction(aggregater);
    var aggregaters = isSingle ? [aggregater] : aggregater;
    var startValues = isSingle ? [startValue] : startValue;
    var out = v.reduce(function (aggregates, x) {
      return aggregaters.map(function (fn, i) {
        return fn(aggregates[i], getter(x));
      });
    }, startValues === undefined ? Array(aggregaters.length).fill(0) : startValues);
    return isSingle ? out[0] : out;
  };
  /**
   * Get the difference of two vectoe
   * @param {array} v - Numerical vectors
   * @param {array} w - Numerical vectors
   * @return {array} Difference vector
   */

  var diff = function diff(v, w) {
    return v.map(function (x, i) {
      return x - w[i];
    });
  };
  /**
   * L distance between a pair of vectors
   *
   * @param {array} l - Defines the Lp space
   * @param {number} dim - Dimension of the input data (Optional)
   */

  var lDist = function lDist(l, dim) {
    if (Number.isNaN(+dim)) {
      /**
       * L distance function
       * @param {array} v - First vector
       * @param {array} w - Second vector
       * @return {array} L distance
       */
      return function (v, w) {
        return v.length === w.length ? Math.pow(v.reduce(function (sum, x, i) {
          return sum + Math.pow(Math.abs(x - w[i]), l);
        }, 0), 1 / l) : undefined;
      };
    }

    var body = Array(dim).fill().map(function (_, i) {
      return "s += Math.abs(v[".concat(i, "] - w[").concat(i, "]) ** l;");
    }).join(' '); // eslint-disable-next-line no-new-func

    return new Function('v', 'w', "const l = ".concat(l, "; let s = 0; ").concat(body, " return s ** (1 / l);"));
  };
  /**
   * L1 distance between a pair of vectors
   *
   * @description
   * This is identical but much faster than `lDist(1)(v, w)`
   *
   * @param {array} v - First vector
   * @param {array} w - Second vector
   * @return {array} L2 distance
   */

  var l1Dist = function l1Dist(v, w) {
    return v.length === w.length ? v.reduce(function (sum, x, i) {
      return sum + Math.abs(x - w[i]);
    }, 0) : undefined;
  };
  /**
   * Creates a l1 distance function tailored to the dimension of the data
   *
   * @description
   * This is identical but faster than `l1Dist(v, w)`
   *
   * @param {number} dim - Dimension of the input data
   * @return {function} A function with the same signature as `l1Dist`
   */

  var l1DistByDim = function l1DistByDim(dim) {
    var body = Array(dim).fill().map(function (_, i) {
      return "s += Math.abs(v[".concat(i, "] - w[").concat(i, "]);");
    }).join(' '); // eslint-disable-next-line no-new-func

    return new Function('v', 'w', "let s = 0; ".concat(body, " return s;"));
  };
  /**
   * L2 distance between a pair of vectors
   *
   * @description
   * This is identical but much faster than `lDist(2)(v, w)`
   *
   * @param {array} v - First vector
   * @param {array} w - Second vector
   * @return {array} L2 distance
   */

  var l2Dist = function l2Dist(v, w) {
    return v.length === w.length ? Math.sqrt(v.reduce(function (sum, x, i) {
      return sum + Math.pow(x - w[i], 2);
    }, 0)) : undefined;
  };
  /**
   * Creates a l2 distance function tailored to the dimension of the data
   *
   * @description
   * This is identical but faster than `l2Dist(v, w)`
   *
   * @param {number} dim - Dimension of the input data
   * @return {function} A function with the same signature as `l2Dist`
   */

  var l2DistByDim = function l2DistByDim(dim) {
    var body = Array(dim).fill().map(function (_, i) {
      return "s += Math.pow(v[".concat(i, "] - w[").concat(i, "], 2);");
    }).join(' '); // eslint-disable-next-line no-new-func

    return new Function('v', 'w', "let s = 0; ".concat(body, " return Math.sqrt(s);"));
  };
  /**
   * Vector L2 norm
   *
   * @description
   * This is identical but much faster than `Math.hypot(...v)`
   *
   * @param {array} v - Numerical vector
   * @return {number} L2 norm
   */

  var l2Norm = function l2Norm(v) {
    return Math.sqrt(v.reduce(function (sum, x) {
      return sum + Math.pow(x, 2);
    }, 0));
  };
  /**
   * Get the maximum number of a vector while ignoring NaNs
   *
   * @description
   * This version is muuuch faster than `Math.max(...v)`.
   *
   * @param {array} v - Numerical vector
   * @return {number} The largest number
   */

  var max = function max(v) {
    return v.reduce(function (_max, a) {
      return a > _max ? a : _max;
    }, -Infinity);
  };
  var maxNan = max;
  /**
   * Get the max vector
   * @param {array} m - Array of vectors
   * @return {array} Max vector
   */

  var maxVector = function maxVector(m) {
    switch (m.length) {
      case 0:
        return [];

      case 1:
        return m[0];

      default:
        return m.reduce(function (_max, v) {
          return v.map(function (x, i) {
            return _max[i] > x ? _max[i] : x;
          });
        }, new Array(m[0].length).fill(-Infinity));
    }
  };
  /**
   * Get the mean of a vector
   *
   * @param {array} v - Numerical vector
   * @return {number} The mean
   */

  var mean = function mean(v) {
    return sum(v) / v.length;
  };
  /**
   * Get the mean of a vector while ignoring NaNs
   *
   * @description
   * Roughly 30% slower than `mean()`
   *
   * @param {array} v - Numerical vector
   * @return {number} The mean
   */

  var meanNan = function meanNan(v) {
    var length = 0;
    return v.reduce(function (s, x) {
      if (x || x === 0) return ++length && s + x;
      return s;
    }, 0) / length;
  };
  /**
   * Get the mean vector
   * @param {array} m - Array of vectors
   * @return {array} Mean vector
   */

  var meanVector = function meanVector(m) {
    switch (m.length) {
      case 0:
        return [];

      case 1:
        return m[0];

      default:
        return m.reduce(function (_mean, v) {
          return v.map(function (x, i) {
            return _mean[i] + x / m.length;
          });
        }, new Array(m[0].length).fill(0));
    }
  };
  /**
   * Get the median of a vector
   *
   * @param {array} v - Numerical vector
   * @return {number} The median
   */

  var median = function median(v) {
    return v[Math.floor(v.length / 2)];
  };
  /**
   * Get the median vector
   * @param {array} m - Array of vectors
   * @return {array} The median vector
   */

  var medianVector = median;
  /**
   * Get the minimum number of a vector while ignoring NaNs
   *
   * @description
   * This version is muuuch faster than `Math.min(...v)` and support longer
   * vectors than 256^2, which is a limitation of `Math.min.apply(null, v)`.
   *
   * @param {array} v - Numerical vector
   * @return {number} The smallest number
   */

  var min = function min(v) {
    return v.reduce(function (_min, a) {
      return a < _min ? a : _min;
    }, Infinity);
  };
  var minNan = min;
  /**
   * Get the min vector
   * @param {array} m - Array of vectors
   * @return {array} Min vector
   */

  var minVector = function minVector(m) {
    switch (m.length) {
      case 0:
        return [];

      case 1:
        return m[0];

      default:
        return m.reduce(function (_min, v) {
          return v.map(function (x, i) {
            return _min[i] < x ? _min[i] : x;
          });
        }, new Array(m[0].length).fill(Infinity));
    }
  };
  /**
   * Non-negative modulo function. E.g., `mod(-1, 5) === 4` while `-1 % 5 === -1`.
   *
   * @param {number} x - Dividend
   * @param {number} y - Divisor
   * @return {number} Remainder
   */

  var mod = function mod(x, y) {
    return (x % y + x) % y;
  };
  /**
   * Normalize vector
   * @param {array} v - Numerical vector
   * @return {array} Unit vector
   */

  var normalize = function normalize(v) {
    var norm = l2Norm(v);
    return v.map(function (x) {
      return x / norm;
    });
  };
  /**
   * A function to created a range array
   * @param   {number}  start  Start of the range (included)
   * @param   {number}  end  End of the range (excluded)
   * @param   {number}  stepSize  Increase per step
   * @return  {array}  Range array
   */

  var range = function range(start, end) {
    var stepSize = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
    return Array(Math.ceil((end - start) / stepSize)).fill().map(function (x, i) {
      return start + i * stepSize;
    });
  };
  /**
   * Get the sum of a vector while ignoring NaNs
   *
   * @description
   *
   *
   * @param {array} v - Numerical vector
   * @return {number} The sum
   */

  var sum = function sum(values) {
    return values.reduce(function (s, v) {
      // Any falsey value (e.g., 0, null, NaN) does not influence the sum
      if (v) return s + v;
      return s;
    }, 0);
  };
  var sumNan = sum;
  /**
   * Get the sum vector
   * @param {array} m - Array of vectors
   * @return {array} Sum vector
   */

  var sumVector = function sumVector(m) {
    switch (m.length) {
      case 0:
        return [];

      case 1:
        return m[0];

      default:
        return m.reduce(function (_sum, v) {
          return v.map(function (x, i) {
            return _sum[i] + x;
          });
        }, new Array(m[0].length).fill(0));
    }
  };

  /**
   * Convert a HEX string to its decimal representation
   * @param {string} hex - HEX string
   * @return {number} Decimal representation
   */

  var decToRgb = function decToRgb(dec) {
    return [dec >> 16, (dec >> 8) % 256, dec % 256];
  };
  /**
   * Convert a HEX string to its decimal representation
   * @param {string} hex - HEX string
   * @return {number} Decimal representation
   */

  var hexToDec = function hexToDec(hex) {
    return parseInt(hex.substr(1), 16);
  };
  /**
   * Convert a HEX-encoded color to an RGB-encoded color
   * @param {string} hex - HEX-encoded color string.
   * @param {boolean} normalize - If `true` the returned RGB values will be
   *   normalized to `[0,1]`.
   * @return {array} Triple holding the RGB values.
   */

  var hexToRgbArray = function hexToRgbArray(hex) {
    var normalize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    return hex.replace(/^#?([a-f\d])([a-f\d])([a-f\d])$/i, function (m, r, g, b) {
      return "#".concat(r).concat(r).concat(g).concat(g).concat(b).concat(b);
    }).substring(1).match(/.{2}/g).map(function (x) {
      return parseInt(x, 16) / Math.pow(255, normalize);
    });
  };
  /**
   * Convert a HEX-encoded color to an RGBA-encoded color
   * @param {string} hex - HEX-encoded color string.
   * @param {boolean} normalize - If `true` the returned RGBA values will be
   *   normalized to `[0,1]`.
   * @return {array} Triple holding the RGBA values.
   */

  var hexToRgbaArray = function hexToRgbaArray(hex) {
    var normalize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    return [].concat(_toConsumableArray(hexToRgbArray(hex, normalize)), [Math.pow(255, !normalize)]);
  };
  /**
   * Convert RGB(A) string to its array representation
   * @param {string} rgbStr - RGB(A) string
   * @return {number} RGB(A) array
   */

  var rgbStrToRgbArray = function rgbStrToRgbArray(rgbStr) {
    return rgbStr.match(/[\d.]+/g).slice(0, 4).map(function (x) {
      return +x;
    });
  };
  /**
   * Same as `rgbStrToRgbArray()`
   */

  var rgbaStrToRgbaArray = rgbStrToRgbArray;
  /**
   * Convert RGB string to its decimal representation
   * @param {string} rgbStr - RGB string
   * @return {number} Decimal representation
   */

  var rgbStrToDec = function rgbStrToDec(rgbStr) {
    return rgbStrToRgbArray(rgbStr).slice(0, 3) // eslint-disable-next-line no-bitwise
    .map(function (x, i) {
      return +x << 8 * (2 - i);
    }).reduce(function (x, sum) {
      return sum + x;
    }, 0);
  };
  /**
   * Convert RGB values to a HEX string
   * @param {number} r - Red component
   * @param {number} g - Green component
   * @param {number} b - Blue component
   * @return {string} HEX string
   */

  var rgbToHex = function rgbToHex(r, g, b) {
    var componentToHex = function componentToHex(c) {
      var hex = c.toString(16);
      return hex.length === 1 ? "0".concat(hex) : hex;
    };

    return "#".concat(componentToHex(r)).concat(componentToHex(g)).concat(componentToHex(b));
  };
  /**
   * Convert a color to an RGBA color
   * @param {*} color - Color to be converted. Currently supports:
   *   HEX, RGB, or RGBA.
   * @param {boolean} normalize - If `true` the returned RGBA values will be
   *   normalized to `[0,1]`.
   * @return{array} Quadruple defining an RGBA color.
   */

  var toRgbaArray = function toRgbaArray(color, normalize$1) {
    if (isRgbaArray(color)) return normalize$1 && !isNormFloatArray(color) ? normalize$1(color) : color;
    if (isRgbArray(color)) return [].concat(_toConsumableArray(normalize$1 ? normalize(color) : color), [Math.pow(255, !normalize$1)]);
    if (isHex(color)) return hexToRgbaArray(color, normalize$1);
    console.warn('Only HEX, RGB, and RGBA are handled by this function. Returning white instead.');
    return normalize$1 ? [1, 1, 1, 1] : [255, 255, 255, 255];
  };

  /**
   * Store the values of an iterator in an array.
   *
   * This code is about 9x faster than `Array.from()`
   *
   * @param   {map}  map  The map whose keys are to be converted to an array
   * @return  {array}  The array with the map keys
   */
  var iteratorToArray = function iteratorToArray(iterator) {
    var keys = []; // eslint-disable-next-line no-restricted-syntax

    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = iterator[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var value = _step.value;
        keys.push(value);
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator["return"] != null) {
          _iterator["return"]();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    return keys;
  };

  var XMLNS = 'http://www.w3.org/2000/svg';
  /**
   * Method to add a class name to an HTML or SVG element.
   * @param {object} element - HTML or SVG element to add a class to.
   * @param {string} className - The class name to be added.
   */

  var addClass = function addClass(element, className) {
    if (element.namespaceURI === XMLNS) {
      if (!hasClass(element, className)) {
        var klass = element.getAttribute('class') || '';
        element.setAttribute('class', "".concat(klass, " ").concat(className));
      }
    } else if (element.classList) {
      element.classList.add(className);
    } else if (!hasClass(element, className)) {
      element.className += " ".concat(className);
    }
  };
  /**
   * Create HTML from a template string
   * @param {string} template - HTML template string
   * @return {node} Root DOM element
   */

  var createHtmlByTemplate = function createHtmlByTemplate(template) {
    var dummyEl = document.createElement('div');
    dummyEl.insertAdjacentHTML('beforeend', template);
    return dummyEl.firstChild;
  };
  /**
   * Check if an HTML or SVG element has a certain class
   * @param {object} element - HTML or SVG element to be checked
   * @param {string} className - Class name to be checked for
   * @return {boolean} If `true` `element` has the class name
   */

  var hasClass = function hasClass(element, className) {
    if (element.namespaceURI === XMLNS) {
      var klass = element.getAttribute('class');
      return klass && !!klass.match(new RegExp("(\\s|^)".concat(className, "(\\s|$)")));
    }

    if (element.classList) return element.classList.contains(className);
    return !!element.className.match(new RegExp("(\\s|^)".concat(className, "(\\s|$)")));
  };
  /**
   * Test whether a DOM element is the parent of another DOM element.
   *
   * @param {object} element - Potential child element.
   * @param {object} parent - Target parent element which is tested to have `el`
   *   as a child.
   * @return {boolean} If `true` `parent` is a parent of `element`.
   */

  var isParentOf = function isParentOf(element, parent) {
    var el = element;

    while (el && el !== parent && el.tagName !== 'HTML') {
      el = el.parentNode;
    }

    return el === parent;
  };
  /**
   * Remove all children of a DOM node
   * @param {object} node - DOM node whose children are to be removed
   */

  var removeAllChildren = function removeAllChildren(node) {
    while (node.firstChild) {
      node.removeChild(node.firstChild);
    }
  };
  /**
   * Remove last child of a DOM node
   * @param {object} node - DOM node whose last child is to be removed
   */

  var removeLastChild = function removeLastChild(node) {
    node.removeChild(node.lastChild);
  };
  /**
   * Remove a class from an HTML or SVG element.
   * @param {object} element - HTML or SVG element.
   * @param {string} className - Class name to be removed.
   */

  var removeClass = function removeClass(element, className) {
    var reg = new RegExp("(\\s|^)".concat(className, "(\\s|$)"));

    if (element.namespaceURI === XMLNS) {
      var klass = element.getAttribute('class') || '';
      element.setAttribute('class', klass.replace(reg, ' '));
    } else if (element.classList) {
      element.classList.remove(className);
    } else if (hasClass(element, className)) {
      element.className = element.className.replace(reg, ' ');
    }
  };

  /**
   * Clone an event by invoking the source event's constructor and passing in
   *   the source event.
   *
   * @param {object} event - Source event to be cloned.
   * @return {object} Cloned event
   */
  var cloneEvent = function cloneEvent(event) {
    var newEvent = new event.constructor(event.type, event);
    newEvent.sourceUid = event.sourceUid;
    newEvent.forwarded = event.forwarded;
    return newEvent;
  };
  /**
   * Forward an event by cloning and dispatching it.
   * @param {object} event - Event to be forwarded.
   * @param {object} target - Target HTML element for the event.
   */

  var forwardEvent = function forwardEvent(event, target) {
    target.dispatchEvent(cloneEvent(event));
  };

  var assign = function assign(target) {
    for (var _len = arguments.length, sources = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      sources[_key - 1] = arguments[_key];
    }

    sources.forEach(function (source) {
      // eslint-disable-next-line no-shadow
      var descriptors = Object.keys(source).reduce(function (descriptors, key) {
        descriptors[key] = Object.getOwnPropertyDescriptor(source, key);
        return descriptors;
      }, {}); // By default, Object.assign copies enumerable Symbols, too

      Object.getOwnPropertySymbols(source).forEach(function (symbol) {
        var descriptor = Object.getOwnPropertyDescriptor(source, symbol);

        if (descriptor.enumerable) {
          descriptors[symbol] = descriptor;
        }
      });
      Object.defineProperties(target, descriptors);
    });
    return target;
  };
  /**
   * Deep clone an object.
   *
   * @param {object} source - Object to be cloned.
   * @return {object} Cloned `source` object.
   */

  var deepClone = function deepClone(source) {
    var target;
    return extend(target, source);
  };
  /**
   * Extend an object with another object.
   *
   * @param {object} target - Target object or `undefined` if a new object should
   *   be created.
   * @param {object} source - Object to be cloned.
   * @return {object} Cloned `source` object
   */

  var extend = function extend(target, source) {
    if (source === null || _typeof(source) !== 'object') {
      return source;
    }

    if (source.constructor !== Object && source.constructor !== Array) {
      return source;
    }

    if (source.constructor === Date || source.constructor === RegExp || source.constructor === Function || source.constructor === String || source.constructor === Number || source.constructor === Boolean) {
      return new source.constructor(source);
    }

    var out = target || new source.constructor();
    Object.keys(source).forEach(function (key) {
      var descriptor = Object.getOwnPropertyDescriptor(source, key);

      if (typeof out[key] === 'undefined') {
        if (typeof descriptor.value === 'undefined') {
          Object.defineProperty(out, key, descriptor);
        } else {
          out[key] = extend(undefined, source[key]);
        }
      }
    });
    return out;
  };
  /**
   * Update the target object by the source object. Besides extending that target
   * object, properties that are not present in the source object.
   *
   * @param {object} target - Target object or `undefined` if a new object should
   *   be created.
   * @param {object} source - Object to be cloned.
   * @return {object} Cloned `source` object
   */

  var update = function update(target, source) {
    // Return boolean, number, strings, and null
    if (source === null || _typeof(source) !== 'object') {
      return source;
    } // Recreate special objects. Special objects are of type "object" but are not
    // simple arrays or objects, e.g.:
    // Date, RegExp, String, Number, Boolean, or Function


    if (source.constructor !== Object && source.constructor !== Array) {
      return new source.constructor(source);
    }

    var out = new target.constructor(); // Update properties

    var updated = false;
    Object.keys(source).forEach(function (key) {
      var descriptor = Object.getOwnPropertyDescriptor(source, key);

      if (target[key] === undefined) {
        // The `key` prop does not exist on `target` so we will extend `target`
        // with the `key` prop.
        if (typeof descriptor.value === 'undefined') {
          Object.defineProperty(out, key, descriptor);
        } else {
          out[key] = extend(undefined, source[key]);
        }
      } else {
        // The `key` prop exist on `target` so we update it.
        out[key] = update(target[key], source[key]);
      }

      updated = updated || out[key] !== target[key];
    }); // In case no property was updated but some were removed `updated` needs to be
    // true

    updated = updated || Object.keys(target).filter(function (key) {
      return typeof source[key] === 'undefined';
    }).length;
    return updated ? out : target;
  };

  var camelToConst = function camelToConst(str) {
    return str.split(/(?=[A-Z])/).join('_').toUpperCase();
  };
  var capitalize = function capitalize(str) {
    return "".concat(str[0].toUpperCase()).concat(str.substr(1));
  };
  /**
   * FInd the nth instance of the query string
   * @param   {string}  str  String to search across
   * @param   {string}  query  String to search for
   * @param   {number}  n  nth instance
   * @return  {number}  Index of the nth query string or -1
   */

  var nthIndexOf = function nthIndexOf(str, query) {
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    var i = 0;
    var idx = str.indexOf(query);

    while (i < n && idx >= 0) {
      idx = str.indexOf(query, idx + 1);
      i++;
    }

    return idx;
  };
  /**
   * Create a random string from some alphabet
   * @param {number} length - Length of the random string
   * @param {string} alphabet - Possible characters
   * @return {string} Random string
   */

  var randomString = function randomString(length) {
    var alphabet = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'abcdefghijklmnopqrstuvwxyz';
    return Array(length).join().split(',').map(function () {
      return alphabet.charAt(Math.floor(Math.random() * alphabet.length));
    }).join('');
  };

  /**
   * Functional version of `Array.map()`
   *
   * @description
   * The pure map function is more powerful because it can be used on data types
   * other than Array too.
   *
   * @param {function} f - Mapping function
   * @return {array} Mapped array
   */

  var map = function map(f) {
    return function (x) {
      return Array.prototype.map.call(x, f);
    };
  };
  /**
   * Map and filter data in one iteration.
   *
   * Combining the loops is about 7-8x faster than
   *
   * @param   {function}  mapFn  Mapping function
   * @param   {function}  filterFn  Filter function
   * @return  {function}  A function that accepts a single array paremeter
   */

  var mapFilter = function mapFilter(mapFn, filterFn) {
    return (
      /**
       * @param   {array}  arr  An array to be mapped and filtered
       * @returns {array}  The mapped and filtered array
       */
      function (arr) {
        var out = []; // loop though array

        for (var i = 0; i < arr.length; i++) {
          var result = mapFn(arr[i], i);
          if (filterFn(result, out.length)) out.push(result);
        }

        return out;
      }
    );
  };
  /**
   * Functional version of `Array.forEach`
   *
   * @description
   * More flexible and applicable to other array-like data types.
   *
   * @param {function} f - Modifier function applied on every item of the array.
   * @return {array} Modified array-like variable.
   */

  var forEach = function forEach(f) {
    return function (x) {
      return Array.prototype.forEach.call(x, f);
    };
  };
  /**
   * Convenience function to compose functions
   * @param {...[function]} fns - Array of functions
   * @return {function} The composed function
   */

  var pipe = function pipe() {
    for (var _len = arguments.length, fns = new Array(_len), _key = 0; _key < _len; _key++) {
      fns[_key] = arguments[_key];
    }

    return (
      /**
       * @param {*} x - Some value
       * @return {*} Output of the composed function
       */
      function (x) {
        return fns.reduce(function (y, f) {
          return f(y);
        }, x);
      }
    );
  };
  /**
   * Functional version of `Array.forEach`. More flexible and applicable to
   *   other array-like data types like `NodeList`.
   * @param   {function}  f  Modifier function applied on every item of the
   *   array.
   * @return  {*}  Modified array-like variable.
   */

  var some = function some(f) {
    return function (x) {
      return Array.prototype.some.call(x, f);
    };
  };
  /**
   * Assign a constructor to the object
   * @param {function} constructor - Constructor functions
   */

  var withConstructor = function withConstructor(constructor) {
    return function (self) {
      return assign({
        __proto__: {
          constructor: constructor
        }
      }, self);
    };
  };
  /**
   * Forward a method call
   * @param {string} name - Exposed function name
   * @param {function} fn - Function to be forwarded
   */

  var withForwardedMethod = function withForwardedMethod(name, fn) {
    return function (self) {
      return assign(self, _defineProperty({}, name, function () {
        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }

        return fn.apply(this, args);
      }));
    };
  };
  /**
   * Assign a property to an object
   * @param {string} name - Name of the property
   * @param {object} options - Option object
   * @param {*} options.initialValue - Initial value of the property
   * @param {function} options.getter - Custom getter
   * @param {function} options.setter - Custom setter
   * @param {function} options.cloner - Clone function. Used before the value
   *   is returned.
   * @param {function} options.transformer - Value transformer. Used before a new
   *   value is set.
   * @param {function} options.validator - Validator function decides whether the
   *   new and transformed value is set or not.
   */

  var withProperty = function withProperty(name) {
    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        _ref$initialValue = _ref.initialValue,
        initialValue = _ref$initialValue === void 0 ? undefined : _ref$initialValue,
        customGetter = _ref.getter,
        customSetter = _ref.setter,
        _ref$cloner = _ref.cloner,
        cloner = _ref$cloner === void 0 ? identity : _ref$cloner,
        _ref$transformer = _ref.transformer,
        transformer = _ref$transformer === void 0 ? identity : _ref$transformer,
        _ref$validator = _ref.validator,
        validator = _ref$validator === void 0 ? function () {
      return true;
    } : _ref$validator;

    return function (self) {
      var _assign2, _mutatorMap;

      var value = initialValue;
      var getter = customGetter ? function () {
        return customGetter();
      } : function () {
        return cloner(value);
      };
      var setter = customSetter ? function (newValue) {
        return customSetter(newValue);
      } : function (newValue) {
        var transformedNewValue = transformer(newValue);
        value = validator(transformedNewValue) ? transformedNewValue : value;
      };
      return assign(self, (_assign2 = {}, _mutatorMap = {}, _mutatorMap[name] = _mutatorMap[name] || {}, _mutatorMap[name].get = function () {
        return getter();
      }, _defineProperty(_assign2, "set".concat(capitalize(name)), function set(newValue) {
        setter(newValue);
      }), _defineEnumerableProperties(_assign2, _mutatorMap), _assign2));
    };
  };
  /**
   * Assign a read-only property to an object
   * @param {string} name - Name of the property
   * @param {function} getter - Getter function
   */

  var withReadOnlyProperty = function withReadOnlyProperty(name, getter) {
    return function (self) {
      var _assign3, _mutatorMap2;

      return assign(self, (_assign3 = {}, _mutatorMap2 = {}, _mutatorMap2[name] = _mutatorMap2[name] || {}, _mutatorMap2[name].get = function () {
        return getter();
      }, _defineEnumerableProperties(_assign3, _mutatorMap2), _assign3));
    };
  };
  /**
   * Assign a static property to an object
   * @param {string} name - Name of the property
   * @param {*} value - Static value
   */

  var withStaticProperty = function withStaticProperty(name, value) {
    return function (self) {
      var _assign4, _mutatorMap3;

      return assign(self, (_assign4 = {}, _mutatorMap3 = {}, _mutatorMap3[name] = _mutatorMap3[name] || {}, _mutatorMap3[name].get = function () {
        return value;
      }, _defineEnumerableProperties(_assign4, _mutatorMap3), _assign4));
    };
  };

  /**
   * L distance between a pair of vectors
   *
   * @description
   * Identical but much faster than `lDist(l)([fromX, fromY], [toX, toY])`
   *
   * @param {number} l - Defines the Lp space
   */
  var lPointDist = function lPointDist(l) {
    return (
      /**
       * L distance function
       * @param {number} fromX - X coordinate of the first point
       * @param {number} fromY - Y coordinate of the first point
       * @param {number} toX - X coordinate of the second point
       * @param {number} toY - Y coordinate of the first point
       * @return {array} L distance
       */
      function (fromX, fromY, toX, toY) {
        return Math.pow(Math.pow(Math.abs(fromX - toX), l) + Math.pow(Math.abs(fromY - toY), l), 1 / l);
      }
    );
  };
  /**
   * L1 distance between a pair of points
   *
   * @description
   * Identical but much faster than `l1Dist([fromX, fromY], [toX, toY])`
   *
   * @param {number} fromX - X coordinate of the first point
   * @param {number} fromY - Y coordinate of the first point
   * @param {number} toX - X coordinate of the second point
   * @param {number} toY - Y coordinate of the first point
   * @return {number} L1 distance
   */

  var l1PointDist = function l1PointDist(fromX, fromY, toX, toY) {
    return Math.abs(fromX - toX) + Math.abs(fromY - toY);
  };
  /**
   * L2 distance between a pair of points
   *
   * @description
   * Identical but much faster than `l2Dist([fromX, fromY], [toX, toY])`
   *
   * @param {number} fromX - X coordinate of the first point
   * @param {number} fromY - Y coordinate of the first point
   * @param {number} toX - X coordinate of the second point
   * @param {number} toY - Y coordinate of the first point
   * @return {number} L2 distance
   */

  var l2PointDist = function l2PointDist(fromX, fromY, toX, toY) {
    return Math.sqrt(Math.pow(fromX - toX, 2) + Math.pow(fromY - toY, 2));
  };
  /**
   * L distance between a pair of rectangles
   *
   * @param {number} l - Defines the Lp space
   */

  var lRectDist = function lRectDist(l) {
    return (
      /**
       * L distance function between a pair of rectangles
       *
       * @param {object} bBox1 - Bounding box of the first rectangle
       * @param {object} bBox2 - Bounding box of the second rectangle
       * @return {number} L distance of the closest boundary points
       */
      function (bBox1, bBox2) {
        var xd1 = bBox2.minX - bBox1.minX;
        var xd2 = bBox2.minX - bBox1.maxX;
        var xd3 = bBox2.maxX - bBox1.minX;
        var xd4 = bBox2.maxX - bBox1.maxX;
        var isXInside = // bBox1 is x-wise inside of bBox2
        xd1 < 0 && xd3 > 0 || xd2 < 0 && xd4 > 0 || // bBox2 is x-wise inside of bBox1
        xd1 > 0 && xd2 < 0 || xd3 > 0 && xd4 < 0;
        var yd1 = bBox2.minY - bBox1.minY;
        var yd2 = bBox2.minY - bBox1.maxY;
        var yd3 = bBox2.maxY - bBox1.minY;
        var yd4 = bBox2.maxY - bBox1.maxY;
        var isYInside = // bBox1 is y-wise inside of bBox2
        yd1 < 0 && yd3 > 0 || yd2 < 0 && yd4 > 0 || // bBox2 is y-wise inside of bBox1
        yd1 > 0 && yd2 < 0 || yd3 > 0 && yd4 < 0;
        if (isXInside && isYInside) return 0;
        var minYDist = Math.min(Math.abs(yd1), Math.abs(yd2), Math.abs(yd3), Math.abs(yd4));
        if (isXInside) return minYDist;
        var minXDist = Math.min(Math.abs(xd1), Math.abs(xd2), Math.abs(xd3), Math.abs(xd4));
        if (isYInside) return minXDist;
        return Math.pow(Math.pow(minXDist, l) + Math.pow(minYDist, l), 1 / l);
      }
    );
  };
  /**
   * From: https://wrf.ecse.rpi.edu//Research/Short_Notes/pnpoly.html
   * @param   {Array}  point  Tuple of the form `[x,y]` to be tested.
   * @param   {Array}  polygon  1D list of vertices defining the polygon.
   * @return  {boolean}  If `true` point lies within the polygon.
   */

  var isPointInPolygon = function isPointInPolygon() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [],
        _ref2 = _slicedToArray(_ref, 2),
        px = _ref2[0],
        py = _ref2[1];

    var polygon = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    var x1;
    var y1;
    var x2;
    var y2;
    var isWithin = false;

    for (var i = 0, j = polygon.length - 2; i < polygon.length; i += 2) {
      x1 = polygon[i];
      y1 = polygon[i + 1];
      x2 = polygon[j];
      y2 = polygon[j + 1];
      if (y1 > py !== y2 > py && px < (x2 - x1) * (py - y1) / (y2 - y1) + x1) isWithin = !isWithin;
      j = i;
    }

    return isWithin;
  };
  /**
   * Check if a 2D or 1D point is within a rectangle or range
   * @param   {number}  x  The point's X coordinate.
   * @param   {number}  y  The point's Y coordinate.
   * @param   {number}  minX  The rectangle's start X coordinate.
   * @param   {number}  maxX  The rectangle's start X coordinate.
   * @param   {number}  minY  The rectangle's start X coordinate.
   * @param   {number}  maxY  The rectangle's start X coordinate.
   * @return  {boolean}  If `true` the [x,y] point is in the rectangle.
   */

  var isPointInRect = function isPointInRect(_ref3, _ref4) {
    var _ref5 = _slicedToArray(_ref3, 2),
        x = _ref5[0],
        y = _ref5[1];

    var _ref6 = _slicedToArray(_ref4, 4),
        minX = _ref6[0],
        maxX = _ref6[1],
        minY = _ref6[2],
        maxY = _ref6[3];

    return x >= minX && x <= maxX && y >= minY && y <= maxY;
  };
  /**
   * Check if a 2D or 1D point is within a rectangle or range
   * @param   {number}  x  The point's X coordinate.
   * @param   {number}  y  The point's Y coordinate.
   * @param   {number}  minX  The rectangle's start X coordinate.
   * @param   {number}  maxX  The rectangle's start X coordinate.
   * @param   {number}  minY  The rectangle's start X coordinate.
   * @param   {number}  maxY  The rectangle's start X coordinate.
   * @return  {boolean}  If `true` the [x,y] point is in the rectangle.
   */

  var isPointHalfwayInRect = function isPointHalfwayInRect(_ref7, _ref8) {
    var _ref9 = _slicedToArray(_ref7, 2),
        x = _ref9[0],
        y = _ref9[1];

    var _ref10 = _slicedToArray(_ref8, 4),
        minX = _ref10[0],
        maxX = _ref10[1],
        minY = _ref10[2],
        maxY = _ref10[3];

    return x >= minX && x <= maxX || y >= minY && y <= maxY;
  };

  var mergeMaps = function mergeMaps(map1, map2) {
    return new Map(
    /*#__PURE__*/
    regeneratorRuntime.mark(function merge() {
      return regeneratorRuntime.wrap(function merge$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              return _context.delegateYield(map1, "t0", 1);

            case 1:
              return _context.delegateYield(map2, "t1", 2);

            case 2:
            case "end":
              return _context.stop();
          }
        }
      }, merge);
    })());
  };

  /**
   * Create a worker from a function
   * @param {function} fn - Function to be turned into a worker
   * @return {Worker} Worker function
   */
  var createWorker = function createWorker(fn) {
    return new Worker(window.URL.createObjectURL(new Blob(["(".concat(fn.toString(), ")()")], {
      type: 'text/javascript'
    })));
  };
  /**
   * An adventure into the void!
   * @return {undefined} The explorers find nothing but void.
   */

  var toVoid = function toVoid() {};

  var sortAsc = function sortAsc(a, b) {
    return a - b;
  };
  var sortDesc = function sortDesc(a, b) {
    return b - a;
  };
  /**
   * Return a list of indices sorted by the array
   *
   * @example
   *   X = [9, 5, 11, -1, 0]
   *   sortedIdx = argSort(X)
   *   >> [3, 4, 1, 0, 2]
   *   I.e., the smallest element is X[sortedIdx[0]] == -1
   *
   * @param {array} array - Array of numerical values
   * @param {function} comparator - Pairwise value comparator function
   * @return {array} Array of indices sorted by the values
   */

  var argSort = function argSort(array) {
    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        _ref$getter = _ref.getter,
        getter = _ref$getter === void 0 ? identity : _ref$getter,
        _ref$comparator = _ref.comparator,
        comparator = _ref$comparator === void 0 ? sortAsc : _ref$comparator,
        _ref$ignoreNull = _ref.ignoreNull,
        ignoreNull = _ref$ignoreNull === void 0 ? false : _ref$ignoreNull;

    return array.map(ignoreNull ? function (x, i) {
      return getter(x) === null ? undefined : [getter(x), i];
    } : function (x, i) {
      return [getter(x), i];
    }).sort(function (a, b) {
      return comparator(a[0], b[0]);
    }).reduce(function (out, tuple) {
      if (!tuple) return out;
      out.push(tuple[1]);
      return out;
    }, []);
  };
  /**
   * Return the sort position of each element in an array or object
   *
   * @example
   *   let array = [9, 5, 11, -1, 0];
   *   let pos = sortPos(array)
   *   >> [3, 2, 4, 0, 1]
   *
   *   let object = { 1: 9, 2: 5, 11: 11, 100: -1, 999: 0 };
   *   let pos = sortPos(object)
   *   >> {1: 9, 2: 5, 11: 11, 100: -1, 999: 0}
   *
   *   I.e., the first element of X is at position idxPos[0] == 3
   *
   * @param {array} array - Array of numerical values
   * @param {function} comparator - Pairwise value comparator function
   * @return {array} Array of the sorted value positions
   */

  var sortPos = function sortPos(source) {
    var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        _ref2$getter = _ref2.getter,
        getter = _ref2$getter === void 0 ? identity : _ref2$getter,
        _ref2$comparator = _ref2.comparator,
        comparator = _ref2$comparator === void 0 ? sortAsc : _ref2$comparator,
        _ref2$ignoreNull = _ref2.ignoreNull,
        ignoreNull = _ref2$ignoreNull === void 0 ? false : _ref2$ignoreNull;

    return Object.entries(source).map(ignoreNull ? function (_ref3) {
      var _ref4 = _slicedToArray(_ref3, 2),
          id = _ref4[0],
          x = _ref4[1];

      return getter(x) === null ? undefined : [id, getter(x)];
    } : function (_ref5) {
      var _ref6 = _slicedToArray(_ref5, 2),
          id = _ref6[0],
          x = _ref6[1];

      return [id, getter(x)];
    }).sort(function (a, b) {
      return comparator(a[1], b[1]);
    }).reduce(function (out, tuple, i) {
      if (!tuple) return out;
      out[tuple[0]] = i;
      return out;
    }, new source.constructor());
  };

  /**
   * Debounce a function call.
   *
   * @description
   * Function calls are delayed by `wait` milliseconds and only one out of
   * multiple function calls is executed.
   *
   * @param {function} fn - Function to be debounced
   * @param {number} wait - Number of milliseconds to debounce the function call.
   * @return {function} Debounced function
   */
  var debounce = function debounce(fn, wait) {
    var timeout;

    var debounced = function debounced() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      var later = function later() {
        timeout = null;
        fn.apply(void 0, args);
      };

      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
    };

    debounced.cancel = function () {
      clearTimeout(timeout);
    };

    debounced.now = function () {
      return fn.apply(void 0, arguments);
    };

    return debounced;
  };
  /**
   * Get a promise that resolves after the next `n` animation frames
   * @param {number} n - Number of animation frames to wait
   * @return {Promise} A promise that resolves after the next `n` animation frames
   */

  var nextAnimationFrame = function nextAnimationFrame() {
    var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
    return new Promise(function (resolve) {
      var i = 0;

      var raf = function raf() {
        return requestAnimationFrame(function () {
          i++;
          if (i < n) raf();else resolve();
        });
      };

      raf();
    });
  };
  /**
   * Throttle a function
   *
   * @description
   * A throttled function will only ever be called every `wait` milliseconds at
   * most.
   *
   * @param {function} fn - Function to be throttled
   * @param {number} wait - Number of milliseconds calls are throttled
   * @return {function} Throttled function
   */

  var throttle = function throttle(fn, wait) {
    var isWaiting = false;

    var throttled = function throttled() {
      if (!isWaiting) {
        fn.apply(void 0, arguments);
        isWaiting = true;
        setTimeout(function () {
          isWaiting = false;
        }, wait);
      }
    };

    throttled.reset = function () {
      isWaiting = false;
    };

    throttled.now = function () {
      return fn.apply(void 0, arguments);
    };

    return throttled;
  };
  /**
   * Throttle and debounce a function call
   *
   * Throttling a function call means that the function is called at most every
   * `interval` milliseconds no matter how frequently you trigger a call.
   * Debouncing a function call means that the function is called the earliest
   * after `finalWait` milliseconds wait time where the function was not called.
   * Combining the two ensures that the function is called at most every
   * `interval` milliseconds and is ensured to be called with the very latest
   * arguments after after `finalWait` milliseconds wait time at the end.
   *
   * The following imaginary scenario describes the behavior:
   *
   * MS | throttleTime=3 and debounceTime=3
   * 1. y(f, 3, 3)(args1) => f(args1) called
   * 2. y(f, 3, 3)(args2) => call ignored due to throttling
   * 3. y(f, 3, 3)(args3) => call ignored due to throttling
   * 4. y(f, 3, 3)(args4) => f(args4) called
   * 5. y(f, 3, 3)(args5) => all ignored due to throttling
   * 6. No call           => nothing
   * 7. No call           => f(args5) called due to debouncing
   *
   * @param {functon} func - Function to be throttled and debounced
   * @param {number} interval - Throttle intevals in milliseconds
   * @param {number} wait - Debounce wait time in milliseconds By default this is
   *   the same as `interval`.
   * @return {function} - Throttled and debounced function
   */

  var throttleAndDebounce = function throttleAndDebounce(fn, throttleTime) {
    var debounceTime = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    var timeout;
    var blockedCalls = 0; // eslint-disable-next-line no-param-reassign

    debounceTime = debounceTime === null ? throttleTime : debounceTime;

    var debounced = function debounced() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      var later = function later() {
        // Since we throttle and debounce we should check whether there were
        // actually multiple attempts to call this function after the most recent
        // throttled call. If there were no more calls we don't have to call
        // the function again.
        if (blockedCalls > 0) {
          fn.apply(void 0, args);
          blockedCalls = 0;
        }
      };

      clearTimeout(timeout);
      timeout = setTimeout(later, debounceTime);
    };

    var isWaiting = false;

    var throttledAndDebounced = function throttledAndDebounced() {
      if (!isWaiting) {
        fn.apply(void 0, arguments);
        debounced.apply(void 0, arguments);
        isWaiting = true;
        blockedCalls = 0;
        setTimeout(function () {
          isWaiting = false;
        }, throttleTime);
      } else {
        blockedCalls++;
        debounced.apply(void 0, arguments);
      }
    };

    throttledAndDebounced.reset = function () {
      isWaiting = false;
    };

    throttledAndDebounced.cancel = function () {
      clearTimeout(timeout);
    };

    throttledAndDebounced.now = function () {
      return fn.apply(void 0, arguments);
    };

    return throttledAndDebounced;
  };
  /**
   * Promise that resolves after some time
   * @param {number} msec - Time in milliseconds until the promise is resolved
   * @return {Promise} Promise resolving after `msec` milliseconds
   */

  var wait = function wait(msec) {
    return new Promise(function (resolve) {
      return setTimeout(resolve, msec);
    });
  };

  var version = "0.25.0";

  exports.addClass = addClass;
  exports.aggregate = aggregate;
  exports.argSort = argSort;
  exports.array2dTranspose = array2dTranspose;
  exports.assign = assign;
  exports.camelToConst = camelToConst;
  exports.capitalize = capitalize;
  exports.clearArray = clearArray;
  exports.cloneEvent = cloneEvent;
  exports.createHtmlByTemplate = createHtmlByTemplate;
  exports.createWorker = createWorker;
  exports.cubicIn = cubicIn;
  exports.cubicInOut = cubicInOut;
  exports.cubicOut = cubicOut;
  exports.debounce = debounce;
  exports.decToRgb = decToRgb;
  exports.deepClone = deepClone;
  exports.diff = diff;
  exports.extend = extend;
  exports.forEach = forEach;
  exports.forwardEvent = forwardEvent;
  exports.hasClass = hasClass;
  exports.hexToDec = hexToDec;
  exports.hexToRgbArray = hexToRgbArray;
  exports.hexToRgbaArray = hexToRgbaArray;
  exports.identity = identity;
  exports.interpolateNumber = interpolateNumber;
  exports.interpolateVector = interpolateVector;
  exports.isArray = isArray;
  exports.isClose = isClose;
  exports.isFunction = isFunction;
  exports.isHex = isHex;
  exports.isNormFloat = isNormFloat;
  exports.isNormFloatArray = isNormFloatArray;
  exports.isNumber = isNumber;
  exports.isObject = isObject;
  exports.isParentOf = isParentOf;
  exports.isPointHalfwayInRect = isPointHalfwayInRect;
  exports.isPointInPolygon = isPointInPolygon;
  exports.isPointInRect = isPointInRect;
  exports.isRgbArray = isRgbArray;
  exports.isRgbStr = isRgbStr;
  exports.isRgbaArray = isRgbaArray;
  exports.isRgbaStr = isRgbaStr;
  exports.isString = isString;
  exports.isUint8 = isUint8;
  exports.isUint8Array = isUint8Array;
  exports.iteratorToArray = iteratorToArray;
  exports.l1Dist = l1Dist;
  exports.l1DistByDim = l1DistByDim;
  exports.l1PointDist = l1PointDist;
  exports.l2Dist = l2Dist;
  exports.l2DistByDim = l2DistByDim;
  exports.l2Norm = l2Norm;
  exports.l2PointDist = l2PointDist;
  exports.lDist = lDist;
  exports.lPointDist = lPointDist;
  exports.lRectDist = lRectDist;
  exports.linear = linear;
  exports.map = map;
  exports.mapFilter = mapFilter;
  exports.max = max;
  exports.maxNan = maxNan;
  exports.maxVector = maxVector;
  exports.mean = mean;
  exports.meanNan = meanNan;
  exports.meanVector = meanVector;
  exports.median = median;
  exports.medianVector = medianVector;
  exports.mergeMaps = mergeMaps;
  exports.min = min;
  exports.minNan = minNan;
  exports.minVector = minVector;
  exports.mod = mod;
  exports.nextAnimationFrame = nextAnimationFrame;
  exports.normalize = normalize;
  exports.nthIndexOf = nthIndexOf;
  exports.pipe = pipe;
  exports.quadIn = quadIn;
  exports.quadInOut = quadInOut;
  exports.quadOut = quadOut;
  exports.quartIn = quartIn;
  exports.quartInOut = quartInOut;
  exports.quartOut = quartOut;
  exports.quintIn = quintIn;
  exports.quintInOut = quintInOut;
  exports.quintOut = quintOut;
  exports.randomString = randomString;
  exports.range = range;
  exports.removeAllChildren = removeAllChildren;
  exports.removeClass = removeClass;
  exports.removeLastChild = removeLastChild;
  exports.rgbStrToDec = rgbStrToDec;
  exports.rgbStrToRgbArray = rgbStrToRgbArray;
  exports.rgbToHex = rgbToHex;
  exports.rgbaStrToRgbaArray = rgbaStrToRgbaArray;
  exports.some = some;
  exports.sortAsc = sortAsc;
  exports.sortDesc = sortDesc;
  exports.sortPos = sortPos;
  exports.sum = sum;
  exports.sumNan = sumNan;
  exports.sumVector = sumVector;
  exports.throttle = throttle;
  exports.throttleAndDebounce = throttleAndDebounce;
  exports.toRgbaArray = toRgbaArray;
  exports.toVoid = toVoid;
  exports.unique = unique;
  exports.update = update;
  exports.version = version;
  exports.wait = wait;
  exports.withConstructor = withConstructor;
  exports.withForwardedMethod = withForwardedMethod;
  exports.withProperty = withProperty;
  exports.withReadOnlyProperty = withReadOnlyProperty;
  exports.withStaticProperty = withStaticProperty;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
