// @flekschas/utils v0.25.0 Copyright 2020 Fritz Lekschas
/**
 * Test if a variable is an array
 * @param {*} f - The variable to test
 * @return {boolean} If `true` the variable is an array.
 */

/**
 * Tests if a string is a valid HEX color encoding
 * @param {string} hex - HEX-encoded color string.
 * @return {boolean} If `true` the string is a valid HEX color encoding.
 */
const isHex = hex =>
  /(^#[0-9A-Fa-f]{6}$)|(^#[0-9A-Fa-f]{3}$)/i.test(hex);

/**
 * Tests if a number is in `[0,1]`.
 * @param {number} x - Number to be tested.
 * @return {boolean} If `true` the number is in `[0,1]`.
 */
const isNormFloat = x => isNumber(x) && x >= 0 && x <= 1;

/**
 * Tests if an array consist of normalized numbers that are in `[0,1]` only.
 * @param {array} a - Array to be tested
 * @return {boolean} If `true` the array contains only numbers in `[0,1]`.
 */
const isNormFloatArray = a => Array.isArray(a) && a.every(isNormFloat);

/**
 * Test if a variable is a number
 * @param {*} x - Variable to be tested
 * @return {boolean} If `true`, `x` is a number.
 */
const isNumber = x => typeof x === 'number';

/**
 * Tests if an array is encoding an RGB color.
 * @param {array} rgb - Array to be tested
 * @return {boolean} If `true` the array hold a triple of Uint8 numbers or
 *   a triple of normalized floats.
 */
const isRgbArray = rgb =>
  rgb.length === 3 && (isNormFloatArray(rgb) || isUint8Array(rgb));

/**
 * Tests if an array is encoding an RGBA color.
 * @param   {array}  rgb  Array to be tested
 * @return  {boolean}  If `true` the array hold a quadruple of normalized floats,
 *   a quadruple of Uint8s, or a triple of Uint8 and one normalized float.
 */
const isRgbaArray = rgba =>
  rgba.length === 4 &&
  (isNormFloatArray(rgba) ||
    isUint8Array(rgba) ||
    (isUint8Array(rgba.slice(0, 3)) && isNormFloat(rgba[3])));

/**
 * Tests if a number is an interger and in `[0,255]`.
 * @param {number} x - Number to be tested.
 * @return {boolean} If `true` the number is an interger and in `[0,255]`.
 */
const isUint8 = x => Number.isInteger(x) && x >= 0 && x <= 255;

/**
 * Tests if an array consist of Uint8 numbers only.
 * @param {array} a - Array to be tested.
 * @return {boolean} If `true` the array contains only Uint8 numbers.
 */
const isUint8Array = a => Array.isArray(a) && a.every(isUint8);

/**
 * Vector L2 norm
 *
 * @description
 * This is identical but much faster than `Math.hypot(...v)`
 *
 * @param {array} v - Numerical vector
 * @return {number} L2 norm
 */
const l2Norm = v => Math.sqrt(v.reduce((sum, x) => sum + x ** 2, 0));

/**
 * Normalize vector
 * @param {array} v - Numerical vector
 * @return {array} Unit vector
 */
const normalize = v => {
  const norm = l2Norm(v);
  return v.map(x => x / norm);
};

/**
 * Convert a HEX string to its decimal representation
 * @param {string} hex - HEX string
 * @return {number} Decimal representation
 */
const decToRgb = dec => [dec >> 16, (dec >> 8) % 256, dec % 256];

/**
 * Convert a HEX string to its decimal representation
 * @param {string} hex - HEX string
 * @return {number} Decimal representation
 */
const hexToDec = hex => parseInt(hex.substr(1), 16);

/**
 * Convert a HEX-encoded color to an RGB-encoded color
 * @param {string} hex - HEX-encoded color string.
 * @param {boolean} normalize - If `true` the returned RGB values will be
 *   normalized to `[0,1]`.
 * @return {array} Triple holding the RGB values.
 */
const hexToRgbArray = (hex, normalize = false) =>
  hex
    .replace(
      /^#?([a-f\d])([a-f\d])([a-f\d])$/i,
      (m, r, g, b) => `#${r}${r}${g}${g}${b}${b}`
    )
    .substring(1)
    .match(/.{2}/g)
    .map(x => parseInt(x, 16) / 255 ** normalize);

/**
 * Convert a HEX-encoded color to an RGBA-encoded color
 * @param {string} hex - HEX-encoded color string.
 * @param {boolean} normalize - If `true` the returned RGBA values will be
 *   normalized to `[0,1]`.
 * @return {array} Triple holding the RGBA values.
 */
const hexToRgbaArray = (hex, normalize = false) => [
  ...hexToRgbArray(hex, normalize),
  255 ** !normalize
];

/**
 * Convert RGB(A) string to its array representation
 * @param {string} rgbStr - RGB(A) string
 * @return {number} RGB(A) array
 */
const rgbStrToRgbArray = rgbStr =>
  rgbStr
    .match(/[\d.]+/g)
    .slice(0, 4)
    .map(x => +x);

/**
 * Same as `rgbStrToRgbArray()`
 */
const rgbaStrToRgbaArray = rgbStrToRgbArray;

/**
 * Convert RGB string to its decimal representation
 * @param {string} rgbStr - RGB string
 * @return {number} Decimal representation
 */
const rgbStrToDec = rgbStr =>
  rgbStrToRgbArray(rgbStr)
    .slice(0, 3)
    // eslint-disable-next-line no-bitwise
    .map((x, i) => +x << (8 * (2 - i)))
    .reduce((x, sum) => sum + x, 0);

/**
 * Convert RGB values to a HEX string
 * @param {number} r - Red component
 * @param {number} g - Green component
 * @param {number} b - Blue component
 * @return {string} HEX string
 */
const rgbToHex = (r, g, b) => {
  const componentToHex = c => {
    const hex = c.toString(16);
    return hex.length === 1 ? `0${hex}` : hex;
  };
  return `#${componentToHex(r)}${componentToHex(g)}${componentToHex(b)}`;
};

/**
 * Convert a color to an RGBA color
 * @param {*} color - Color to be converted. Currently supports:
 *   HEX, RGB, or RGBA.
 * @param {boolean} normalize - If `true` the returned RGBA values will be
 *   normalized to `[0,1]`.
 * @return{array} Quadruple defining an RGBA color.
 */
const toRgbaArray = (color, normalize$1) => {
  if (isRgbaArray(color))
    return normalize$1 && !isNormFloatArray(color) ? normalize$1(color) : color;

  if (isRgbArray(color))
    return [...(normalize$1 ? normalize(color) : color), 255 ** !normalize$1];

  if (isHex(color)) return hexToRgbaArray(color, normalize$1);

  console.warn(
    'Only HEX, RGB, and RGBA are handled by this function. Returning white instead.'
  );

  return normalize$1 ? [1, 1, 1, 1] : [255, 255, 255, 255];
};

export { decToRgb, hexToDec, hexToRgbArray, hexToRgbaArray, rgbStrToDec, rgbStrToRgbArray, rgbToHex, rgbaStrToRgbaArray, toRgbaArray };
