// @flekschas/utils v0.25.0 Copyright 2020 Fritz Lekschas
/* eslint no-param-reassign:0 */

/**
 * Cubic in easing function
 * @param {number} t - The input time to be eased. Must be in [0, 1] where `0`
 *   refers to the start and `1` to the end
 * @return {number} The eased time
 */
const cubicIn = t => t * t * t;

/**
 * Cubic in and out easing function
 * @param {number} t - The input time to be eased. Must be in [0, 1] where `0`
 *   refers to the start and `1` to the end
 * @return {number} The eased time
 */
const cubicInOut = t =>
  t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;

/**
 * Cubic out easing function
 * @param {number} t - The input time to be eased. Must be in [0, 1] where `0`
 *   refers to the start and `1` to the end
 * @return {number} The eased time
 */
const cubicOut = t => --t * t * t + 1;

/**
 * Linearly interpolate two numbers
 * @param {number} a - The start value
 * @param {number} b - The end value
 * @param {number} p - The interpolation progress. Must be in [0, 1] where `0`
 *   refers to the start value and `1` to the end value
 * @return {number} The interpolated number
 */
const interpolateNumber = (a, b, p) => {
  // eslint-disable-next-line no-param-reassign
  p = Math.min(1, Math.max(0, p));
  return a * (1 - p) + b * p;
};

/**
 * Lineraly interpolate a numerical vector
 * @param {array} a - The start vector
 * @param {array} b - The end vector
 * @param {number} p - The interpolation progress. Must be in [0, 1] where `0`
 *   refers to the start vector and `1` to the end vector
 * @return {array} The interpolated vector
 */
const interpolateVector = (a, b, p) =>
  a.map((x, i) => interpolateNumber(x, b[i], p));

/**
 * Linear easing function
 * @param {number} t - The input time to be eased. Must be in [0, 1] where `0`
 *   refers to the start and `1` to the end
 * @return {number} Same as the input
 */
const linear = t => t;

/**
 * Quadratic in easing function
 * @param {number} t - The input time to be eased. Must be in [0, 1] where `0`
 *   refers to the start and `1` to the end
 * @return {number} The eased time
 */
const quadIn = t => t * t;

/**
 * Quadratic in and out easing function
 * @param {number} t - The input time to be eased. Must be in [0, 1] where `0`
 *   refers to the start and `1` to the end
 * @return {number} The eased time
 */
const quadInOut = t => (t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t);

/**
 * Quadratic out easing function
 * @param {number} t - The input time to be eased. Must be in [0, 1] where `0`
 *   refers to the start and `1` to the end
 * @return {number} The eased time
 */
const quadOut = t => t * (2 - t);

/**
 * Quartic in easing function
 * @param {number} t - The input time to be eased. Must be in [0, 1] where `0`
 *   refers to the start and `1` to the end
 * @return {number} The eased time
 */
const quartIn = t => t * t * t * t;

/**
 * Quartic in and out easing function
 * @param {number} t - The input time to be eased. Must be in [0, 1] where `0`
 *   refers to the start and `1` to the end
 * @return {number} The eased time
 */
const quartOut = t => 1 - --t * t * t * t;

/**
 * Quartic out easing function
 * @param {number} t - The input time to be eased. Must be in [0, 1] where `0`
 *   refers to the start and `1` to the end
 * @return {number} The eased time
 */
const quartInOut = t =>
  t < 0.5 ? 8 * t * t * t * t : 1 - 8 * --t * t * t * t;

/**
 * Quintic in easing function
 * @param {number} t - The input time to be eased. Must be in [0, 1] where `0`
 *   refers to the start and `1` to the end
 * @return {number} The eased time
 */
const quintIn = t => t * t * t * t * t;

/**
 * Quintic in and out easing function
 * @param {number} t - The input time to be eased. Must be in [0, 1] where `0`
 *   refers to the start and `1` to the end
 * @return {number} The eased time
 */
const quintOut = t => 1 + --t * t * t * t * t;

/**
 * Quintic out easing function
 * @param {number} t - The input time to be eased. Must be in [0, 1] where `0`
 *   refers to the start and `1` to the end
 * @return {number} The eased time
 */
const quintInOut = t =>
  t < 0.5 ? 16 * t * t * t * t * t : 1 + 16 * --t * t * t * t * t;

/**
 * Identity function
 * @param   {*}  x  Any kind of value
 * @return  {*}  `x`
 */
const identity = x => x;

/**
 * Test if two floats are close given some precision
 * @param {number} a - First float
 * @param {number} b - Second float
 * @param {number} precision - Number of decimal places to check
 * @return {boolean} If `true` the difference between the floats is less than
 *   10^-precision
 */
const isClose = (a, b, precision = 6) =>
  Math.abs(a - b) < 10 ** -precision;

/**
 * Transpose a nested 2D array
 * @param {array} matrix - The matrix-liked 2D nested array to be transposed
 * @return {array} The transposed 2D nested matrix-like array
 */
const array2dTranspose = matrix => {
  // Create a nested 2D array with transposed shape
  const out = [...new Array(matrix[0].length).fill().map(() => [])];

  // Fill the transposed array
  for (let i = 0; i < matrix.length; i++) {
    for (let j = 0; j < matrix[i].length; j++) {
      out[j][i] = matrix[i][j];
    }
  }

  return out;
};

/**
 * Clear an array without while keeping it's reference
 * @param {array} a - Array to be cleared
 * @return {array} The array itself
 */
const clearArray = a => {
  a.splice(0, a.length);
  return a;
};

/**
 * Return unique values of an array
 * @param {array} a - Input array
 * @return {array} Array with unique values
 */
const unique = (a, getter = identity) => {
  const s = new Set();
  const out = [];

  for (let i = 0; i < a.length; i++) {
    const v = getter(a[i]);
    if (!s.has(v)) {
      s.add(v);
      out.push(v);
    }
  }

  return out;
};

/**
 * Test if a variable is an array
 * @param {*} f - The variable to test
 * @return {boolean} If `true` the variable is an array.
 */
const isArray = Array.isArray;

/**
 * Test if a variable is a function
 * @param {*} f - The variable to test
 * @return {boolean} If `true` the variable is a function.
 */
const isFunction = f => !!(f && f.constructor && f.call && f.apply);

/**
 * Tests if a string is a valid HEX color encoding
 * @param {string} hex - HEX-encoded color string.
 * @return {boolean} If `true` the string is a valid HEX color encoding.
 */
const isHex = hex =>
  /(^#[0-9A-Fa-f]{6}$)|(^#[0-9A-Fa-f]{3}$)/i.test(hex);

/**
 * Tests if a number is in `[0,1]`.
 * @param {number} x - Number to be tested.
 * @return {boolean} If `true` the number is in `[0,1]`.
 */
const isNormFloat = x => isNumber(x) && x >= 0 && x <= 1;

/**
 * Tests if an array consist of normalized numbers that are in `[0,1]` only.
 * @param {array} a - Array to be tested
 * @return {boolean} If `true` the array contains only numbers in `[0,1]`.
 */
const isNormFloatArray = a => Array.isArray(a) && a.every(isNormFloat);

/**
 * Test if a variable is a number
 * @param {*} x - Variable to be tested
 * @return {boolean} If `true`, `x` is a number.
 */
const isNumber = x => typeof x === 'number';

/**
 * Test if a variable is a plain object, e.g., `{}`
 * @param {*} o - The variable to test
 * @return {boolean} If `true` the variable is a plain object.
 */
const isObject = o => !!o && o.constructor === Object;

/**
 * Tests if an array is encoding an RGB color.
 * @param {array} rgb - Array to be tested
 * @return {boolean} If `true` the array hold a triple of Uint8 numbers or
 *   a triple of normalized floats.
 */
const isRgbArray = rgb =>
  rgb.length === 3 && (isNormFloatArray(rgb) || isUint8Array(rgb));

/**
 * Tests if an array is encoding an RGBA color.
 * @param   {array}  rgb  Array to be tested
 * @return  {boolean}  If `true` the array hold a quadruple of normalized floats,
 *   a quadruple of Uint8s, or a triple of Uint8 and one normalized float.
 */
const isRgbaArray = rgba =>
  rgba.length === 4 &&
  (isNormFloatArray(rgba) ||
    isUint8Array(rgba) ||
    (isUint8Array(rgba.slice(0, 3)) && isNormFloat(rgba[3])));

/**
 * Tests if a string is encoding an RGB color.
 * @param {string} rgb - String to be tested
 * @return {boolean} If `true` the array hold a triple of Uint8 numbers or
 *   a triple of normalized floats.
 */
const isRgbStr = str =>
  /rgb\(\s*[\d.]+\s*,\s*[\d.]+\s*,\s*[\d.]+\s*\)/i.test(str);

/**
 * Tests if a string is encoding an RGBA color.
 * @param {string} rgb - String to be tested
 * @return {boolean} If `true` the array hold a quadruple of Uint8 numbers or
 *   a quadruple of normalized floats.
 */
const isRgbaStr = str =>
  /rgba\(\s*[\d.]+\s*,\s*[\d.]+\s*,\s*[\d.]+\s*,\s*[\d.]+\s*\)/i.test(str);

/**
 * Tests if a variable is a string
 * @param {*} s - Variable to be tested
 * @return {boolean} If `true` variable is a string
 */
const isString = s => typeof s === 'string' || s instanceof String;

/**
 * Tests if a number is an interger and in `[0,255]`.
 * @param {number} x - Number to be tested.
 * @return {boolean} If `true` the number is an interger and in `[0,255]`.
 */
const isUint8 = x => Number.isInteger(x) && x >= 0 && x <= 255;

/**
 * Tests if an array consist of Uint8 numbers only.
 * @param {array} a - Array to be tested.
 * @return {boolean} If `true` the array contains only Uint8 numbers.
 */
const isUint8Array = a => Array.isArray(a) && a.every(isUint8);

/**
 * Aggregate a vector using one or more aggregators. Like a multi-purpose reducer.
 * @param {array} v - Numerivcal vector
 * @param {array|function} aggregater - A single or multiple aggregator functions. The aggregator functions work like reducers.
 * @param {array|number} startValue - A single or multiple start values
 * @param {function} options.getter - A value getter
 * @return {array|number} A single or multiple aggregagted values
 */
const aggregate = (
  v,
  aggregater,
  startValue,
  { getter = identity } = {}
) => {
  const isSingle = isFunction(aggregater);

  const aggregaters = isSingle ? [aggregater] : aggregater;
  const startValues = isSingle ? [startValue] : startValue;

  const out = v.reduce(
    (aggregates, x) => aggregaters.map((fn, i) => fn(aggregates[i], getter(x))),
    startValues === undefined ? Array(aggregaters.length).fill(0) : startValues
  );

  return isSingle ? out[0] : out;
};

/**
 * Get the difference of two vectoe
 * @param {array} v - Numerical vectors
 * @param {array} w - Numerical vectors
 * @return {array} Difference vector
 */
const diff = (v, w) => v.map((x, i) => x - w[i]);

/**
 * L distance between a pair of vectors
 *
 * @param {array} l - Defines the Lp space
 * @param {number} dim - Dimension of the input data (Optional)
 */
const lDist = (l, dim) => {
  if (Number.isNaN(+dim)) {
    /**
     * L distance function
     * @param {array} v - First vector
     * @param {array} w - Second vector
     * @return {array} L distance
     */
    return (v, w) =>
      v.length === w.length
        ? v.reduce((sum, x, i) => sum + Math.abs(x - w[i]) ** l, 0) ** (1 / l)
        : undefined;
  }

  const body = Array(dim)
    .fill()
    .map((_, i) => `s += Math.abs(v[${i}] - w[${i}]) ** l;`)
    .join(' ');
  // eslint-disable-next-line no-new-func
  return new Function(
    'v',
    'w',
    `const l = ${l}; let s = 0; ${body} return s ** (1 / l);`
  );
};

/**
 * L1 distance between a pair of vectors
 *
 * @description
 * This is identical but much faster than `lDist(1)(v, w)`
 *
 * @param {array} v - First vector
 * @param {array} w - Second vector
 * @return {array} L2 distance
 */
const l1Dist = (v, w) =>
  v.length === w.length
    ? v.reduce((sum, x, i) => sum + Math.abs(x - w[i]), 0)
    : undefined;

/**
 * Creates a l1 distance function tailored to the dimension of the data
 *
 * @description
 * This is identical but faster than `l1Dist(v, w)`
 *
 * @param {number} dim - Dimension of the input data
 * @return {function} A function with the same signature as `l1Dist`
 */
const l1DistByDim = dim => {
  const body = Array(dim)
    .fill()
    .map((_, i) => `s += Math.abs(v[${i}] - w[${i}]);`)
    .join(' ');
  // eslint-disable-next-line no-new-func
  return new Function('v', 'w', `let s = 0; ${body} return s;`);
};

/**
 * L2 distance between a pair of vectors
 *
 * @description
 * This is identical but much faster than `lDist(2)(v, w)`
 *
 * @param {array} v - First vector
 * @param {array} w - Second vector
 * @return {array} L2 distance
 */
const l2Dist = (v, w) =>
  v.length === w.length
    ? Math.sqrt(v.reduce((sum, x, i) => sum + (x - w[i]) ** 2, 0))
    : undefined;

/**
 * Creates a l2 distance function tailored to the dimension of the data
 *
 * @description
 * This is identical but faster than `l2Dist(v, w)`
 *
 * @param {number} dim - Dimension of the input data
 * @return {function} A function with the same signature as `l2Dist`
 */
const l2DistByDim = dim => {
  const body = Array(dim)
    .fill()
    .map((_, i) => `s += Math.pow(v[${i}] - w[${i}], 2);`)
    .join(' ');
  // eslint-disable-next-line no-new-func
  return new Function('v', 'w', `let s = 0; ${body} return Math.sqrt(s);`);
};

/**
 * Vector L2 norm
 *
 * @description
 * This is identical but much faster than `Math.hypot(...v)`
 *
 * @param {array} v - Numerical vector
 * @return {number} L2 norm
 */
const l2Norm = v => Math.sqrt(v.reduce((sum, x) => sum + x ** 2, 0));

/**
 * Get the maximum number of a vector while ignoring NaNs
 *
 * @description
 * This version is muuuch faster than `Math.max(...v)`.
 *
 * @param {array} v - Numerical vector
 * @return {number} The largest number
 */
const max = v => v.reduce((_max, a) => (a > _max ? a : _max), -Infinity);

const maxNan = max;

/**
 * Get the max vector
 * @param {array} m - Array of vectors
 * @return {array} Max vector
 */
const maxVector = m => {
  switch (m.length) {
    case 0:
      return [];

    case 1:
      return m[0];

    default:
      return m.reduce(
        (_max, v) => v.map((x, i) => (_max[i] > x ? _max[i] : x)),
        new Array(m[0].length).fill(-Infinity)
      );
  }
};

/**
 * Get the mean of a vector
 *
 * @param {array} v - Numerical vector
 * @return {number} The mean
 */
const mean = v => sum(v) / v.length;

/**
 * Get the mean of a vector while ignoring NaNs
 *
 * @description
 * Roughly 30% slower than `mean()`
 *
 * @param {array} v - Numerical vector
 * @return {number} The mean
 */
const meanNan = v => {
  let length = 0;
  return (
    v.reduce((s, x) => {
      if (x || x === 0) return ++length && s + x;
      return s;
    }, 0) / length
  );
};

/**
 * Get the mean vector
 * @param {array} m - Array of vectors
 * @return {array} Mean vector
 */
const meanVector = m => {
  switch (m.length) {
    case 0:
      return [];

    case 1:
      return m[0];

    default:
      return m.reduce(
        (_mean, v) => v.map((x, i) => _mean[i] + x / m.length),
        new Array(m[0].length).fill(0)
      );
  }
};

/**
 * Get the median of a vector
 *
 * @param {array} v - Numerical vector
 * @return {number} The median
 */
const median = v => v[Math.floor(v.length / 2)];

/**
 * Get the median vector
 * @param {array} m - Array of vectors
 * @return {array} The median vector
 */
const medianVector = median;

/**
 * Get the minimum number of a vector while ignoring NaNs
 *
 * @description
 * This version is muuuch faster than `Math.min(...v)` and support longer
 * vectors than 256^2, which is a limitation of `Math.min.apply(null, v)`.
 *
 * @param {array} v - Numerical vector
 * @return {number} The smallest number
 */
const min = v => v.reduce((_min, a) => (a < _min ? a : _min), Infinity);

const minNan = min;

/**
 * Get the min vector
 * @param {array} m - Array of vectors
 * @return {array} Min vector
 */
const minVector = m => {
  switch (m.length) {
    case 0:
      return [];

    case 1:
      return m[0];

    default:
      return m.reduce(
        (_min, v) => v.map((x, i) => (_min[i] < x ? _min[i] : x)),
        new Array(m[0].length).fill(Infinity)
      );
  }
};

/**
 * Non-negative modulo function. E.g., `mod(-1, 5) === 4` while `-1 % 5 === -1`.
 *
 * @param {number} x - Dividend
 * @param {number} y - Divisor
 * @return {number} Remainder
 */
const mod = (x, y) => ((x % y) + x) % y;

/**
 * Normalize vector
 * @param {array} v - Numerical vector
 * @return {array} Unit vector
 */
const normalize = v => {
  const norm = l2Norm(v);
  return v.map(x => x / norm);
};

/**
 * A function to created a range array
 * @param   {number}  start  Start of the range (included)
 * @param   {number}  end  End of the range (excluded)
 * @param   {number}  stepSize  Increase per step
 * @return  {array}  Range array
 */
const range = (start, end, stepSize = 1) =>
  Array(Math.ceil((end - start) / stepSize))
    .fill()
    .map((x, i) => start + i * stepSize);

/**
 * Get the sum of a vector while ignoring NaNs
 *
 * @description
 *
 *
 * @param {array} v - Numerical vector
 * @return {number} The sum
 */
const sum = values =>
  values.reduce((s, v) => {
    // Any falsey value (e.g., 0, null, NaN) does not influence the sum
    if (v) return s + v;
    return s;
  }, 0);

const sumNan = sum;

/**
 * Get the sum vector
 * @param {array} m - Array of vectors
 * @return {array} Sum vector
 */
const sumVector = m => {
  switch (m.length) {
    case 0:
      return [];

    case 1:
      return m[0];

    default:
      return m.reduce(
        (_sum, v) => v.map((x, i) => _sum[i] + x),
        new Array(m[0].length).fill(0)
      );
  }
};

/**
 * Convert a HEX string to its decimal representation
 * @param {string} hex - HEX string
 * @return {number} Decimal representation
 */
const decToRgb = dec => [dec >> 16, (dec >> 8) % 256, dec % 256];

/**
 * Convert a HEX string to its decimal representation
 * @param {string} hex - HEX string
 * @return {number} Decimal representation
 */
const hexToDec = hex => parseInt(hex.substr(1), 16);

/**
 * Convert a HEX-encoded color to an RGB-encoded color
 * @param {string} hex - HEX-encoded color string.
 * @param {boolean} normalize - If `true` the returned RGB values will be
 *   normalized to `[0,1]`.
 * @return {array} Triple holding the RGB values.
 */
const hexToRgbArray = (hex, normalize = false) =>
  hex
    .replace(
      /^#?([a-f\d])([a-f\d])([a-f\d])$/i,
      (m, r, g, b) => `#${r}${r}${g}${g}${b}${b}`
    )
    .substring(1)
    .match(/.{2}/g)
    .map(x => parseInt(x, 16) / 255 ** normalize);

/**
 * Convert a HEX-encoded color to an RGBA-encoded color
 * @param {string} hex - HEX-encoded color string.
 * @param {boolean} normalize - If `true` the returned RGBA values will be
 *   normalized to `[0,1]`.
 * @return {array} Triple holding the RGBA values.
 */
const hexToRgbaArray = (hex, normalize = false) => [
  ...hexToRgbArray(hex, normalize),
  255 ** !normalize
];

/**
 * Convert RGB(A) string to its array representation
 * @param {string} rgbStr - RGB(A) string
 * @return {number} RGB(A) array
 */
const rgbStrToRgbArray = rgbStr =>
  rgbStr
    .match(/[\d.]+/g)
    .slice(0, 4)
    .map(x => +x);

/**
 * Same as `rgbStrToRgbArray()`
 */
const rgbaStrToRgbaArray = rgbStrToRgbArray;

/**
 * Convert RGB string to its decimal representation
 * @param {string} rgbStr - RGB string
 * @return {number} Decimal representation
 */
const rgbStrToDec = rgbStr =>
  rgbStrToRgbArray(rgbStr)
    .slice(0, 3)
    // eslint-disable-next-line no-bitwise
    .map((x, i) => +x << (8 * (2 - i)))
    .reduce((x, sum) => sum + x, 0);

/**
 * Convert RGB values to a HEX string
 * @param {number} r - Red component
 * @param {number} g - Green component
 * @param {number} b - Blue component
 * @return {string} HEX string
 */
const rgbToHex = (r, g, b) => {
  const componentToHex = c => {
    const hex = c.toString(16);
    return hex.length === 1 ? `0${hex}` : hex;
  };
  return `#${componentToHex(r)}${componentToHex(g)}${componentToHex(b)}`;
};

/**
 * Convert a color to an RGBA color
 * @param {*} color - Color to be converted. Currently supports:
 *   HEX, RGB, or RGBA.
 * @param {boolean} normalize - If `true` the returned RGBA values will be
 *   normalized to `[0,1]`.
 * @return{array} Quadruple defining an RGBA color.
 */
const toRgbaArray = (color, normalize$1) => {
  if (isRgbaArray(color))
    return normalize$1 && !isNormFloatArray(color) ? normalize$1(color) : color;

  if (isRgbArray(color))
    return [...(normalize$1 ? normalize(color) : color), 255 ** !normalize$1];

  if (isHex(color)) return hexToRgbaArray(color, normalize$1);

  console.warn(
    'Only HEX, RGB, and RGBA are handled by this function. Returning white instead.'
  );

  return normalize$1 ? [1, 1, 1, 1] : [255, 255, 255, 255];
};

/**
 * Store the values of an iterator in an array.
 *
 * This code is about 9x faster than `Array.from()`
 *
 * @param   {map}  map  The map whose keys are to be converted to an array
 * @return  {array}  The array with the map keys
 */
const iteratorToArray = iterator => {
  const keys = [];
  // eslint-disable-next-line no-restricted-syntax
  for (const value of iterator) {
    keys.push(value);
  }
  return keys;
};

const XMLNS = 'http://www.w3.org/2000/svg';

/**
 * Method to add a class name to an HTML or SVG element.
 * @param {object} element - HTML or SVG element to add a class to.
 * @param {string} className - The class name to be added.
 */
const addClass = (element, className) => {
  if (element.namespaceURI === XMLNS) {
    if (!hasClass(element, className)) {
      const klass = element.getAttribute('class') || '';
      element.setAttribute('class', `${klass} ${className}`);
    }
  } else if (element.classList) {
    element.classList.add(className);
  } else if (!hasClass(element, className)) {
    element.className += ` ${className}`;
  }
};

/**
 * Create HTML from a template string
 * @param {string} template - HTML template string
 * @return {node} Root DOM element
 */
const createHtmlByTemplate = template => {
  const dummyEl = document.createElement('div');
  dummyEl.insertAdjacentHTML('beforeend', template);
  return dummyEl.firstChild;
};

/**
 * Check if an HTML or SVG element has a certain class
 * @param {object} element - HTML or SVG element to be checked
 * @param {string} className - Class name to be checked for
 * @return {boolean} If `true` `element` has the class name
 */
const hasClass = (element, className) => {
  if (element.namespaceURI === XMLNS) {
    const klass = element.getAttribute('class');
    return klass && !!klass.match(new RegExp(`(\\s|^)${className}(\\s|$)`));
  }

  if (element.classList) return element.classList.contains(className);

  return !!element.className.match(new RegExp(`(\\s|^)${className}(\\s|$)`));
};

/**
 * Test whether a DOM element is the parent of another DOM element.
 *
 * @param {object} element - Potential child element.
 * @param {object} parent - Target parent element which is tested to have `el`
 *   as a child.
 * @return {boolean} If `true` `parent` is a parent of `element`.
 */
const isParentOf = (element, parent) => {
  let el = element;

  while (el && el !== parent && el.tagName !== 'HTML') {
    el = el.parentNode;
  }

  return el === parent;
};

/**
 * Remove all children of a DOM node
 * @param {object} node - DOM node whose children are to be removed
 */
const removeAllChildren = node => {
  while (node.firstChild) {
    node.removeChild(node.firstChild);
  }
};

/**
 * Remove last child of a DOM node
 * @param {object} node - DOM node whose last child is to be removed
 */
const removeLastChild = node => {
  node.removeChild(node.lastChild);
};

/**
 * Remove a class from an HTML or SVG element.
 * @param {object} element - HTML or SVG element.
 * @param {string} className - Class name to be removed.
 */
const removeClass = (element, className) => {
  const reg = new RegExp(`(\\s|^)${className}(\\s|$)`);

  if (element.namespaceURI === XMLNS) {
    const klass = element.getAttribute('class') || '';
    element.setAttribute('class', klass.replace(reg, ' '));
  } else if (element.classList) {
    element.classList.remove(className);
  } else if (hasClass(element, className)) {
    element.className = element.className.replace(reg, ' ');
  }
};

/**
 * Clone an event by invoking the source event's constructor and passing in
 *   the source event.
 *
 * @param {object} event - Source event to be cloned.
 * @return {object} Cloned event
 */
const cloneEvent = event => {
  const newEvent = new event.constructor(event.type, event);
  newEvent.sourceUid = event.sourceUid;
  newEvent.forwarded = event.forwarded;

  return newEvent;
};

/**
 * Forward an event by cloning and dispatching it.
 * @param {object} event - Event to be forwarded.
 * @param {object} target - Target HTML element for the event.
 */
const forwardEvent = (event, target) => {
  target.dispatchEvent(cloneEvent(event));
};

const assign = (target, ...sources) => {
  sources.forEach(source => {
    // eslint-disable-next-line no-shadow
    const descriptors = Object.keys(source).reduce((descriptors, key) => {
      descriptors[key] = Object.getOwnPropertyDescriptor(source, key);
      return descriptors;
    }, {});

    // By default, Object.assign copies enumerable Symbols, too
    Object.getOwnPropertySymbols(source).forEach(symbol => {
      const descriptor = Object.getOwnPropertyDescriptor(source, symbol);
      if (descriptor.enumerable) {
        descriptors[symbol] = descriptor;
      }
    });
    Object.defineProperties(target, descriptors);
  });
  return target;
};

/**
 * Deep clone an object.
 *
 * @param {object} source - Object to be cloned.
 * @return {object} Cloned `source` object.
 */
const deepClone = source => {
  let target;
  return extend(target, source);
};

/**
 * Extend an object with another object.
 *
 * @param {object} target - Target object or `undefined` if a new object should
 *   be created.
 * @param {object} source - Object to be cloned.
 * @return {object} Cloned `source` object
 */
const extend = (target, source) => {
  if (source === null || typeof source !== 'object') {
    return source;
  }

  if (source.constructor !== Object && source.constructor !== Array) {
    return source;
  }

  if (
    source.constructor === Date ||
    source.constructor === RegExp ||
    source.constructor === Function ||
    source.constructor === String ||
    source.constructor === Number ||
    source.constructor === Boolean
  ) {
    return new source.constructor(source);
  }

  const out = target || new source.constructor();

  Object.keys(source).forEach(key => {
    const descriptor = Object.getOwnPropertyDescriptor(source, key);
    if (typeof out[key] === 'undefined') {
      if (typeof descriptor.value === 'undefined') {
        Object.defineProperty(out, key, descriptor);
      } else {
        out[key] = extend(undefined, source[key]);
      }
    }
  });

  return out;
};

/**
 * Update the target object by the source object. Besides extending that target
 * object, properties that are not present in the source object.
 *
 * @param {object} target - Target object or `undefined` if a new object should
 *   be created.
 * @param {object} source - Object to be cloned.
 * @return {object} Cloned `source` object
 */
const update = (target, source) => {
  // Return boolean, number, strings, and null
  if (source === null || typeof source !== 'object') {
    return source;
  }

  // Recreate special objects. Special objects are of type "object" but are not
  // simple arrays or objects, e.g.:
  // Date, RegExp, String, Number, Boolean, or Function
  if (source.constructor !== Object && source.constructor !== Array) {
    return new source.constructor(source);
  }

  const out = new target.constructor();

  // Update properties
  let updated = false;
  Object.keys(source).forEach(key => {
    const descriptor = Object.getOwnPropertyDescriptor(source, key);
    if (target[key] === undefined) {
      // The `key` prop does not exist on `target` so we will extend `target`
      // with the `key` prop.
      if (typeof descriptor.value === 'undefined') {
        Object.defineProperty(out, key, descriptor);
      } else {
        out[key] = extend(undefined, source[key]);
      }
    } else {
      // The `key` prop exist on `target` so we update it.
      out[key] = update(target[key], source[key]);
    }
    updated = updated || out[key] !== target[key];
  });

  // In case no property was updated but some were removed `updated` needs to be
  // true
  updated =
    updated ||
    Object.keys(target).filter(key => typeof source[key] === 'undefined')
      .length;

  return updated ? out : target;
};

const camelToConst = str =>
  str
    .split(/(?=[A-Z])/)
    .join('_')
    .toUpperCase();

const capitalize = str => `${str[0].toUpperCase()}${str.substr(1)}`;

/**
 * FInd the nth instance of the query string
 * @param   {string}  str  String to search across
 * @param   {string}  query  String to search for
 * @param   {number}  n  nth instance
 * @return  {number}  Index of the nth query string or -1
 */
const nthIndexOf = (str, query, n = 0) => {
  let i = 0;
  let idx = str.indexOf(query);
  while (i < n && idx >= 0) {
    idx = str.indexOf(query, idx + 1);
    i++;
  }
  return idx;
};

/**
 * Create a random string from some alphabet
 * @param {number} length - Length of the random string
 * @param {string} alphabet - Possible characters
 * @return {string} Random string
 */
const randomString = (length, alphabet = 'abcdefghijklmnopqrstuvwxyz') =>
  Array(length)
    .join()
    .split(',')
    .map(() => alphabet.charAt(Math.floor(Math.random() * alphabet.length)))
    .join('');

/**
 * Functional version of `Array.map()`
 *
 * @description
 * The pure map function is more powerful because it can be used on data types
 * other than Array too.
 *
 * @param {function} f - Mapping function
 * @return {array} Mapped array
 */
const map = f => x => Array.prototype.map.call(x, f);

/**
 * Map and filter data in one iteration.
 *
 * Combining the loops is about 7-8x faster than
 *
 * @param   {function}  mapFn  Mapping function
 * @param   {function}  filterFn  Filter function
 * @return  {function}  A function that accepts a single array paremeter
 */
const mapFilter = (mapFn, filterFn) =>
  /**
   * @param   {array}  arr  An array to be mapped and filtered
   * @returns {array}  The mapped and filtered array
   */
  arr => {
    const out = [];
    // loop though array
    for (let i = 0; i < arr.length; i++) {
      const result = mapFn(arr[i], i);
      if (filterFn(result, out.length)) out.push(result);
    }
    return out;
  };

/**
 * Functional version of `Array.forEach`
 *
 * @description
 * More flexible and applicable to other array-like data types.
 *
 * @param {function} f - Modifier function applied on every item of the array.
 * @return {array} Modified array-like variable.
 */
const forEach = f => x => Array.prototype.forEach.call(x, f);

/**
 * Convenience function to compose functions
 * @param {...[function]} fns - Array of functions
 * @return {function} The composed function
 */
const pipe = (...fns) =>
  /**
   * @param {*} x - Some value
   * @return {*} Output of the composed function
   */
  x => fns.reduce((y, f) => f(y), x);

/**
 * Functional version of `Array.forEach`. More flexible and applicable to
 *   other array-like data types like `NodeList`.
 * @param   {function}  f  Modifier function applied on every item of the
 *   array.
 * @return  {*}  Modified array-like variable.
 */
const some = f => x => Array.prototype.some.call(x, f);

/**
 * Assign a constructor to the object
 * @param {function} constructor - Constructor functions
 */
const withConstructor = constructor => self =>
  assign(
    {
      __proto__: {
        constructor
      }
    },
    self
  );

/**
 * Forward a method call
 * @param {string} name - Exposed function name
 * @param {function} fn - Function to be forwarded
 */
const withForwardedMethod = (name, fn) => self =>
  assign(self, {
    [name](...args) {
      return fn.apply(this, args);
    }
  });

/**
 * Assign a property to an object
 * @param {string} name - Name of the property
 * @param {object} options - Option object
 * @param {*} options.initialValue - Initial value of the property
 * @param {function} options.getter - Custom getter
 * @param {function} options.setter - Custom setter
 * @param {function} options.cloner - Clone function. Used before the value
 *   is returned.
 * @param {function} options.transformer - Value transformer. Used before a new
 *   value is set.
 * @param {function} options.validator - Validator function decides whether the
 *   new and transformed value is set or not.
 */
const withProperty = (
  name,
  {
    initialValue = undefined,
    getter: customGetter,
    setter: customSetter,
    cloner = identity,
    transformer = identity,
    validator = () => true
  } = {}
) => self => {
  let value = initialValue;

  const getter = customGetter ? () => customGetter() : () => cloner(value);

  const setter = customSetter
    ? newValue => customSetter(newValue)
    : newValue => {
        const transformedNewValue = transformer(newValue);
        value = validator(transformedNewValue) ? transformedNewValue : value;
      };

  return assign(self, {
    get [name]() {
      return getter();
    },
    [`set${capitalize(name)}`](newValue) {
      setter(newValue);
    }
  });
};

/**
 * Assign a read-only property to an object
 * @param {string} name - Name of the property
 * @param {function} getter - Getter function
 */
const withReadOnlyProperty = (name, getter) => self =>
  assign(self, {
    get [name]() {
      return getter();
    }
  });

/**
 * Assign a static property to an object
 * @param {string} name - Name of the property
 * @param {*} value - Static value
 */
const withStaticProperty = (name, value) => self =>
  assign(self, {
    get [name]() {
      return value;
    }
  });

/**
 * L distance between a pair of vectors
 *
 * @description
 * Identical but much faster than `lDist(l)([fromX, fromY], [toX, toY])`
 *
 * @param {number} l - Defines the Lp space
 */
const lPointDist = l =>
  /**
   * L distance function
   * @param {number} fromX - X coordinate of the first point
   * @param {number} fromY - Y coordinate of the first point
   * @param {number} toX - X coordinate of the second point
   * @param {number} toY - Y coordinate of the first point
   * @return {array} L distance
   */
  (fromX, fromY, toX, toY) =>
    (Math.abs(fromX - toX) ** l + Math.abs(fromY - toY) ** l) ** (1 / l);

/**
 * L1 distance between a pair of points
 *
 * @description
 * Identical but much faster than `l1Dist([fromX, fromY], [toX, toY])`
 *
 * @param {number} fromX - X coordinate of the first point
 * @param {number} fromY - Y coordinate of the first point
 * @param {number} toX - X coordinate of the second point
 * @param {number} toY - Y coordinate of the first point
 * @return {number} L1 distance
 */
const l1PointDist = (fromX, fromY, toX, toY) =>
  Math.abs(fromX - toX) + Math.abs(fromY - toY);

/**
 * L2 distance between a pair of points
 *
 * @description
 * Identical but much faster than `l2Dist([fromX, fromY], [toX, toY])`
 *
 * @param {number} fromX - X coordinate of the first point
 * @param {number} fromY - Y coordinate of the first point
 * @param {number} toX - X coordinate of the second point
 * @param {number} toY - Y coordinate of the first point
 * @return {number} L2 distance
 */
const l2PointDist = (fromX, fromY, toX, toY) =>
  Math.sqrt((fromX - toX) ** 2 + (fromY - toY) ** 2);

/**
 * L distance between a pair of rectangles
 *
 * @param {number} l - Defines the Lp space
 */
const lRectDist = l =>
  /**
   * L distance function between a pair of rectangles
   *
   * @param {object} bBox1 - Bounding box of the first rectangle
   * @param {object} bBox2 - Bounding box of the second rectangle
   * @return {number} L distance of the closest boundary points
   */
  (bBox1, bBox2) => {
    const xd1 = bBox2.minX - bBox1.minX;
    const xd2 = bBox2.minX - bBox1.maxX;
    const xd3 = bBox2.maxX - bBox1.minX;
    const xd4 = bBox2.maxX - bBox1.maxX;

    const isXInside =
      // bBox1 is x-wise inside of bBox2
      (xd1 < 0 && xd3 > 0) ||
      (xd2 < 0 && xd4 > 0) ||
      // bBox2 is x-wise inside of bBox1
      (xd1 > 0 && xd2 < 0) ||
      (xd3 > 0 && xd4 < 0);

    const yd1 = bBox2.minY - bBox1.minY;
    const yd2 = bBox2.minY - bBox1.maxY;
    const yd3 = bBox2.maxY - bBox1.minY;
    const yd4 = bBox2.maxY - bBox1.maxY;

    const isYInside =
      // bBox1 is y-wise inside of bBox2
      (yd1 < 0 && yd3 > 0) ||
      (yd2 < 0 && yd4 > 0) ||
      // bBox2 is y-wise inside of bBox1
      (yd1 > 0 && yd2 < 0) ||
      (yd3 > 0 && yd4 < 0);

    if (isXInside && isYInside) return 0;

    const minYDist = Math.min(
      Math.abs(yd1),
      Math.abs(yd2),
      Math.abs(yd3),
      Math.abs(yd4)
    );

    if (isXInside) return minYDist;

    const minXDist = Math.min(
      Math.abs(xd1),
      Math.abs(xd2),
      Math.abs(xd3),
      Math.abs(xd4)
    );

    if (isYInside) return minXDist;

    return (minXDist ** l + minYDist ** l) ** (1 / l);
  };

/**
 * From: https://wrf.ecse.rpi.edu//Research/Short_Notes/pnpoly.html
 * @param   {Array}  point  Tuple of the form `[x,y]` to be tested.
 * @param   {Array}  polygon  1D list of vertices defining the polygon.
 * @return  {boolean}  If `true` point lies within the polygon.
 */
const isPointInPolygon = ([px, py] = [], polygon = []) => {
  let x1;
  let y1;
  let x2;
  let y2;
  let isWithin = false;
  for (let i = 0, j = polygon.length - 2; i < polygon.length; i += 2) {
    x1 = polygon[i];
    y1 = polygon[i + 1];
    x2 = polygon[j];
    y2 = polygon[j + 1];
    if (y1 > py !== y2 > py && px < ((x2 - x1) * (py - y1)) / (y2 - y1) + x1)
      isWithin = !isWithin;
    j = i;
  }
  return isWithin;
};

/**
 * Check if a 2D or 1D point is within a rectangle or range
 * @param   {number}  x  The point's X coordinate.
 * @param   {number}  y  The point's Y coordinate.
 * @param   {number}  minX  The rectangle's start X coordinate.
 * @param   {number}  maxX  The rectangle's start X coordinate.
 * @param   {number}  minY  The rectangle's start X coordinate.
 * @param   {number}  maxY  The rectangle's start X coordinate.
 * @return  {boolean}  If `true` the [x,y] point is in the rectangle.
 */
const isPointInRect = ([x, y], [minX, maxX, minY, maxY]) =>
  x >= minX && x <= maxX && y >= minY && y <= maxY;

/**
 * Check if a 2D or 1D point is within a rectangle or range
 * @param   {number}  x  The point's X coordinate.
 * @param   {number}  y  The point's Y coordinate.
 * @param   {number}  minX  The rectangle's start X coordinate.
 * @param   {number}  maxX  The rectangle's start X coordinate.
 * @param   {number}  minY  The rectangle's start X coordinate.
 * @param   {number}  maxY  The rectangle's start X coordinate.
 * @return  {boolean}  If `true` the [x,y] point is in the rectangle.
 */
const isPointHalfwayInRect = ([x, y], [minX, maxX, minY, maxY]) =>
  (x >= minX && x <= maxX) || (y >= minY && y <= maxY);

const mergeMaps = (map1, map2) =>
  new Map(
    (function* merge() {
      yield* map1;
      yield* map2;
    })()
  );

/**
 * Create a worker from a function
 * @param {function} fn - Function to be turned into a worker
 * @return {Worker} Worker function
 */
const createWorker = fn =>
  new Worker(
    window.URL.createObjectURL(
      new Blob([`(${fn.toString()})()`], { type: 'text/javascript' })
    )
  );

/**
 * An adventure into the void!
 * @return {undefined} The explorers find nothing but void.
 */
const toVoid = () => {};

const sortAsc = (a, b) => a - b;

const sortDesc = (a, b) => b - a;

/**
 * Return a list of indices sorted by the array
 *
 * @example
 *   X = [9, 5, 11, -1, 0]
 *   sortedIdx = argSort(X)
 *   >> [3, 4, 1, 0, 2]
 *   I.e., the smallest element is X[sortedIdx[0]] == -1
 *
 * @param {array} array - Array of numerical values
 * @param {function} comparator - Pairwise value comparator function
 * @return {array} Array of indices sorted by the values
 */
const argSort = (
  array,
  { getter = identity, comparator = sortAsc, ignoreNull = false } = {}
) =>
  array
    .map(
      ignoreNull
        ? (x, i) => (getter(x) === null ? undefined : [getter(x), i])
        : (x, i) => [getter(x), i]
    )
    .sort((a, b) => comparator(a[0], b[0]))
    .reduce((out, tuple) => {
      if (!tuple) return out;
      out.push(tuple[1]);
      return out;
    }, []);

/**
 * Return the sort position of each element in an array or object
 *
 * @example
 *   let array = [9, 5, 11, -1, 0];
 *   let pos = sortPos(array)
 *   >> [3, 2, 4, 0, 1]
 *
 *   let object = { 1: 9, 2: 5, 11: 11, 100: -1, 999: 0 };
 *   let pos = sortPos(object)
 *   >> {1: 9, 2: 5, 11: 11, 100: -1, 999: 0}
 *
 *   I.e., the first element of X is at position idxPos[0] == 3
 *
 * @param {array} array - Array of numerical values
 * @param {function} comparator - Pairwise value comparator function
 * @return {array} Array of the sorted value positions
 */
const sortPos = (
  source,
  { getter = identity, comparator = sortAsc, ignoreNull = false } = {}
) =>
  Object.entries(source)
    .map(
      ignoreNull
        ? ([id, x]) => (getter(x) === null ? undefined : [id, getter(x)])
        : ([id, x]) => [id, getter(x)]
    )
    .sort((a, b) => comparator(a[1], b[1]))
    .reduce((out, tuple, i) => {
      if (!tuple) return out;
      out[tuple[0]] = i;
      return out;
    }, new source.constructor());

/**
 * Debounce a function call.
 *
 * @description
 * Function calls are delayed by `wait` milliseconds and only one out of
 * multiple function calls is executed.
 *
 * @param {function} fn - Function to be debounced
 * @param {number} wait - Number of milliseconds to debounce the function call.
 * @return {function} Debounced function
 */
const debounce = (fn, wait) => {
  let timeout;

  const debounced = (...args) => {
    const later = () => {
      timeout = null;
      fn(...args);
    };

    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
  };

  debounced.cancel = () => {
    clearTimeout(timeout);
  };

  debounced.now = (...args) => fn(...args);

  return debounced;
};

/**
 * Get a promise that resolves after the next `n` animation frames
 * @param {number} n - Number of animation frames to wait
 * @return {Promise} A promise that resolves after the next `n` animation frames
 */
const nextAnimationFrame = (n = 1) =>
  new Promise(resolve => {
    let i = 0;

    const raf = () =>
      requestAnimationFrame(() => {
        i++;
        if (i < n) raf();
        else resolve();
      });

    raf();
  });

/**
 * Throttle a function
 *
 * @description
 * A throttled function will only ever be called every `wait` milliseconds at
 * most.
 *
 * @param {function} fn - Function to be throttled
 * @param {number} wait - Number of milliseconds calls are throttled
 * @return {function} Throttled function
 */
const throttle = (fn, wait) => {
  let isWaiting = false;

  const throttled = (...args) => {
    if (!isWaiting) {
      fn(...args);

      isWaiting = true;

      setTimeout(() => {
        isWaiting = false;
      }, wait);
    }
  };

  throttled.reset = () => {
    isWaiting = false;
  };

  throttled.now = (...args) => fn(...args);

  return throttled;
};

/**
 * Throttle and debounce a function call
 *
 * Throttling a function call means that the function is called at most every
 * `interval` milliseconds no matter how frequently you trigger a call.
 * Debouncing a function call means that the function is called the earliest
 * after `finalWait` milliseconds wait time where the function was not called.
 * Combining the two ensures that the function is called at most every
 * `interval` milliseconds and is ensured to be called with the very latest
 * arguments after after `finalWait` milliseconds wait time at the end.
 *
 * The following imaginary scenario describes the behavior:
 *
 * MS | throttleTime=3 and debounceTime=3
 * 1. y(f, 3, 3)(args1) => f(args1) called
 * 2. y(f, 3, 3)(args2) => call ignored due to throttling
 * 3. y(f, 3, 3)(args3) => call ignored due to throttling
 * 4. y(f, 3, 3)(args4) => f(args4) called
 * 5. y(f, 3, 3)(args5) => all ignored due to throttling
 * 6. No call           => nothing
 * 7. No call           => f(args5) called due to debouncing
 *
 * @param {functon} func - Function to be throttled and debounced
 * @param {number} interval - Throttle intevals in milliseconds
 * @param {number} wait - Debounce wait time in milliseconds By default this is
 *   the same as `interval`.
 * @return {function} - Throttled and debounced function
 */
const throttleAndDebounce = (fn, throttleTime, debounceTime = null) => {
  let timeout;
  let blockedCalls = 0;

  // eslint-disable-next-line no-param-reassign
  debounceTime = debounceTime === null ? throttleTime : debounceTime;

  const debounced = (...args) => {
    const later = () => {
      // Since we throttle and debounce we should check whether there were
      // actually multiple attempts to call this function after the most recent
      // throttled call. If there were no more calls we don't have to call
      // the function again.
      if (blockedCalls > 0) {
        fn(...args);
        blockedCalls = 0;
      }
    };

    clearTimeout(timeout);
    timeout = setTimeout(later, debounceTime);
  };

  let isWaiting = false;
  const throttledAndDebounced = (...args) => {
    if (!isWaiting) {
      fn(...args);
      debounced(...args);

      isWaiting = true;
      blockedCalls = 0;

      setTimeout(() => {
        isWaiting = false;
      }, throttleTime);
    } else {
      blockedCalls++;
      debounced(...args);
    }
  };

  throttledAndDebounced.reset = () => {
    isWaiting = false;
  };

  throttledAndDebounced.cancel = () => {
    clearTimeout(timeout);
  };

  throttledAndDebounced.now = (...args) => fn(...args);

  return throttledAndDebounced;
};

/**
 * Promise that resolves after some time
 * @param {number} msec - Time in milliseconds until the promise is resolved
 * @return {Promise} Promise resolving after `msec` milliseconds
 */
const wait = msec => new Promise(resolve => setTimeout(resolve, msec));

var version = "0.25.0";

export { addClass, aggregate, argSort, array2dTranspose, assign, camelToConst, capitalize, clearArray, cloneEvent, createHtmlByTemplate, createWorker, cubicIn, cubicInOut, cubicOut, debounce, decToRgb, deepClone, diff, extend, forEach, forwardEvent, hasClass, hexToDec, hexToRgbArray, hexToRgbaArray, identity, interpolateNumber, interpolateVector, isArray, isClose, isFunction, isHex, isNormFloat, isNormFloatArray, isNumber, isObject, isParentOf, isPointHalfwayInRect, isPointInPolygon, isPointInRect, isRgbArray, isRgbStr, isRgbaArray, isRgbaStr, isString, isUint8, isUint8Array, iteratorToArray, l1Dist, l1DistByDim, l1PointDist, l2Dist, l2DistByDim, l2Norm, l2PointDist, lDist, lPointDist, lRectDist, linear, map, mapFilter, max, maxNan, maxVector, mean, meanNan, meanVector, median, medianVector, mergeMaps, min, minNan, minVector, mod, nextAnimationFrame, normalize, nthIndexOf, pipe, quadIn, quadInOut, quadOut, quartIn, quartInOut, quartOut, quintIn, quintInOut, quintOut, randomString, range, removeAllChildren, removeClass, removeLastChild, rgbStrToDec, rgbStrToRgbArray, rgbToHex, rgbaStrToRgbaArray, some, sortAsc, sortDesc, sortPos, sum, sumNan, sumVector, throttle, throttleAndDebounce, toRgbaArray, toVoid, unique, update, version, wait, withConstructor, withForwardedMethod, withProperty, withReadOnlyProperty, withStaticProperty };
